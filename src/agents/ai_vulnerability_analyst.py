"""
CrewAI-based Vulnerability Analysis Agent with XAI (Explainable AI)
"""
import os
import json
from typing import Dict, Any, List
from datetime import datetime

try:
    from crewai import Agent, Task, Crew
    from langchain_anthropic import ChatAnthropic
    from langchain_openai import ChatOpenAI
    CREWAI_AVAILABLE = True
except ImportError:
    CREWAI_AVAILABLE = False
    print("⚠️ CrewAI not available. Install with: pip install crewai langchain-anthropic")


class AIVulnerabilityAnalyst:
    """AI-powered vulnerability analyst with explainable reasoning"""
    
    def __init__(self):
        self.llm = None
        if CREWAI_AVAILABLE:
            # Try Anthropic Claude first, fallback to OpenAI
            anthropic_key = os.getenv("ANTHROPIC_API_KEY")
            openai_key = os.getenv("OPENAI_API_KEY")
            
            if anthropic_key:
                self.llm = ChatAnthropic(
                    model="claude-3-sonnet-20240229",
                    api_key=anthropic_key
                )
            elif openai_key:
                self.llm = ChatOpenAI(
                    model="gpt-4",
                    api_key=openai_key
                )
    
    def create_vulnerability_analyst_agent(self) -> Agent:
        """Create vulnerability analysis agent"""
        if not CREWAI_AVAILABLE or not self.llm:
            return None
        
        return Agent(
            role='Senior Vulnerability Analyst',
            goal='Analyze network services and identify critical security vulnerabilities with detailed explanations',
            backstory="""You are an expert cybersecurity analyst with 15+ years of experience in 
            vulnerability assessment and penetration testing. You specialize in identifying CVEs, 
            analyzing their exploitability, and providing clear explanations of why each vulnerability 
            is relevant to the target system.""",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
    
    def create_cve_researcher_agent(self) -> Agent:
        """Create CVE research agent"""
        if not CREWAI_AVAILABLE or not self.llm:
            return None
        
        return Agent(
            role='CVE Research Specialist',
            goal='Research and validate CVEs with proof-of-concept availability',
            backstory="""You are a CVE research specialist who excels at finding relevant 
            vulnerabilities from databases like NVD, ExploitDB, and GitHub. You provide 
            detailed context about each CVE including CVSS scores, attack vectors, and 
            available exploits.""",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
    
    def create_xai_explainer_agent(self) -> Agent:
        """Create XAI (Explainable AI) agent"""
        if not CREWAI_AVAILABLE or not self.llm:
            return None
        
        return Agent(
            role='Security Explanation Specialist',
            goal='Provide clear, detailed explanations of vulnerability analysis reasoning',
            backstory="""You are an expert at explaining complex security concepts in clear terms. 
            You specialize in providing step-by-step reasoning for why specific CVEs were identified, 
            what evidence supports each finding, and what the potential impact is.""",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
    
    async def analyze_vulnerabilities(
        self, 
        scan_results: Dict[str, Any],
        osint_data: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Analyze scan results and identify vulnerabilities with AI reasoning
        """
        if not CREWAI_AVAILABLE or not self.llm:
            return self._fallback_analysis(scan_results)
        
        # Create agents
        vuln_analyst = self.create_vulnerability_analyst_agent()
        cve_researcher = self.create_cve_researcher_agent()
        xai_explainer = self.create_xai_explainer_agent()
        
        # Prepare context
        services_context = self._prepare_services_context(scan_results, osint_data)
        
        # Create tasks
        analysis_task = Task(
            description=f"""Analyze the following network services and identify potential vulnerabilities:
            
            {services_context}
            
            For each identified vulnerability:
            1. Identify the specific CVE
            2. Explain why this service/version is vulnerable
            3. Assess the severity and impact
            4. Determine exploitability
            
            Return results in JSON format with: cve, service, port, version, cvss_score, severity, description, reasoning
            """,
            agent=vuln_analyst,
            expected_output="JSON formatted vulnerability analysis"
        )
        
        cve_research_task = Task(
            description=f"""Research and validate the CVEs identified in the analysis.
            
            For each CVE:
            1. Verify it exists in NVD database
            2. Find proof-of-concept exploits if available
            3. Identify attack prerequisites
            4. Assess real-world exploitability
            
            Enhance the vulnerability data with PoC availability and exploit details.
            """,
            agent=cve_researcher,
            expected_output="Enhanced CVE data with exploit information"
        )
        
        explanation_task = Task(
            description=f"""Provide detailed explanations for the vulnerability findings.
            
            For each identified vulnerability, explain:
            1. WHY was this CVE identified? (Evidence-based reasoning)
            2. WHAT makes this service vulnerable? (Technical details)
            3. HOW could this be exploited? (Attack vector)
            4. WHAT is the potential impact? (Business impact)
            
            Create a clear reasoning chain that shows the logical steps taken.
            """,
            agent=xai_explainer,
            expected_output="Detailed XAI explanations for each vulnerability"
        )
        
        # Create crew
        crew = Crew(
            agents=[vuln_analyst, cve_researcher, xai_explainer],
            tasks=[analysis_task, cve_research_task, explanation_task],
            verbose=True
        )
        
        # Execute analysis
        try:
            result = crew.kickoff()
            
            # Parse and structure results
            return self._structure_ai_results(result, scan_results)
        
        except Exception as e:
            print(f"AI analysis error: {e}")
            return self._fallback_analysis(scan_results)
    
    def _prepare_services_context(
        self, 
        scan_results: Dict[str, Any], 
        osint_data: Dict[str, Any] = None
    ) -> str:
        """Prepare context for AI analysis"""
        context = []
        
        # Add scan results
        if scan_results and "ports" in scan_results:
            context.append("=== DETECTED SERVICES ===")
            for port in scan_results["ports"]:
                context.append(
                    f"Port {port['port']}/{port['protocol']}: "
                    f"{port['service']} {port.get('version', 'unknown version')}"
                )
        
        # Add OSINT context if available
        if osint_data:
            context.append("\n=== OSINT INTELLIGENCE ===")
            if "ssl_info" in osint_data:
                context.append(f"SSL: {osint_data['ssl_info']}")
            if "dns_records" in osint_data:
                context.append(f"DNS: {osint_data['dns_records']}")
        
        return "\n".join(context)
    
    def _structure_ai_results(
        self, 
        ai_result: str, 
        scan_results: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Structure AI analysis results"""
        
        # Try to parse AI output
        try:
            # Extract JSON from AI response
            if isinstance(ai_result, str):
                # Find JSON in response
                import re
                json_match = re.search(r'\{.*\}', ai_result, re.DOTALL)
                if json_match:
                    result_data = json.loads(json_match.group())
                else:
                    result_data = {"raw_output": ai_result}
            else:
                result_data = ai_result
            
            return {
                "timestamp": datetime.now().isoformat(),
                "analysis_method": "AI-powered (CrewAI)",
                "ai_reasoning": result_data,
                "vulnerabilities": result_data.get("vulnerabilities", []),
                "xai_explanations": result_data.get("explanations", {}),
                "confidence_scores": result_data.get("confidence", {}),
                "attack_chains": result_data.get("attack_chains", [])
            }
        
        except Exception as e:
            print(f"Error structuring AI results: {e}")
            return {
                "timestamp": datetime.now().isoformat(),
                "analysis_method": "AI-powered (CrewAI)",
                "raw_ai_output": str(ai_result),
                "error": str(e)
            }
    
    def _fallback_analysis(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Fallback analysis without AI"""
        vulnerabilities = []
        
        # Simple pattern matching for known vulnerable services
        vulnerable_services = {
            "Apache httpd 2.4.6": {
                "cve": "CVE-2021-44228",
                "description": "Potential Log4Shell vulnerability in Apache",
                "severity": "CRITICAL",
                "reasoning": "Apache 2.4.6 may contain vulnerable Log4j library"
            },
            "OpenSSH 7.4": {
                "cve": "CVE-2018-15473",
                "description": "OpenSSH Username Enumeration",
                "severity": "MEDIUM",
                "reasoning": "OpenSSH 7.4 is vulnerable to username enumeration attacks"
            },
            "MySQL 5.7": {
                "cve": "CVE-2020-14559",
                "description": "MySQL Server vulnerability",
                "severity": "HIGH",
                "reasoning": "MySQL 5.7 versions prior to 5.7.31 are vulnerable"
            }
        }
        
        if scan_results and "ports" in scan_results:
            for port in scan_results["ports"]:
                service_version = f"{port['service']} {port.get('version', '')}"
                
                for vuln_key, vuln_data in vulnerable_services.items():
                    if vuln_key.lower() in service_version.lower():
                        vulnerabilities.append({
                            **vuln_data,
                            "port": port["port"],
                            "service": port["service"],
                            "cvss_score": 7.5,
                            "xai_explanation": {
                                "why_identified": vuln_data["reasoning"],
                                "evidence": f"Service version match: {service_version}",
                                "attack_vector": "Network-based exploitation",
                                "impact": "Potential remote code execution"
                            }
                        })
        
        return {
            "timestamp": datetime.now().isoformat(),
            "analysis_method": "Pattern-based (Fallback)",
            "vulnerabilities": vulnerabilities,
            "xai_explanations": {
                v["cve"]: v.get("xai_explanation", {}) 
                for v in vulnerabilities
            }
        }


# Global instance
_ai_analyst = None

def get_ai_vulnerability_analyst() -> AIVulnerabilityAnalyst:
    """Get global AI analyst instance"""
    global _ai_analyst
    if _ai_analyst is None:
        _ai_analyst = AIVulnerabilityAnalyst()
    return _ai_analyst
