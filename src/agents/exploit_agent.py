from pathlib import Path
import subprocess
import json
import shutil
import time


def run_exploit(target: str, poc_info: dict, work_dir: Path, authorize: bool = False) -> Path:
    """Run Zerologon PoC (LAB-only). If no real PoC chosen, fallback to tester.
    Telemetry logged with stages and timing.
    """
    log_path = work_dir / "exploit.log"
    telemetry = []
    t0 = time.time()

    def log(stage: str, message: str):
        telemetry.append({"t": round(time.time()-t0,3), "stage": stage, "msg": message})

    if not authorize:
        log("auth", "Authorization not granted. Skipping exploit.")
        log_path.write_text(json.dumps(telemetry, indent=2))
        return log_path

    selected = (poc_info or {}).get("selected") or {}
    repo_url = selected.get("url")
    repo_name = selected.get("name")
    repo_dir = work_dir / "poc_repo"

    # Try cloning selected PoC if available
    if repo_url and shutil.which("git"):
        try:
            log("clone", f"Cloning {repo_name}")
            if repo_dir.exists():
                shutil.rmtree(repo_dir, ignore_errors=True)
            subprocess.run(["git", "clone", "--depth", "1", repo_url, str(repo_dir)], check=True, capture_output=True, text=True, timeout=120)
        except Exception as e:
            log("clone", f"clone_failed: {e}")
    else:
        log("clone", "No repo selected or git not available")

    # Fallback tester if no standardized runner
    tester = work_dir / "zerologon_tester.py"
    if not tester.exists():
        tester.write_text(
            """#!/usr/bin/env python3\nimport sys, socket\n\nif __name__ == '__main__':\n    ip = sys.argv[1] if len(sys.argv) > 1 else '127.0.0.1'\n    s = socket.socket()\n    s.settimeout(3)\n    res = s.connect_ex((ip, 445))\n    print('VULNERABLE' if res == 0 else 'NOT_ACCESSIBLE')\n"""
        )
        try:
            tester.chmod(0o755)
        except Exception:
            pass

    # Execute tester as default
    try:
        log("exec", f"Running tester against {target}")
        out = subprocess.run(["python3", str(tester), target], capture_output=True, text=True, timeout=30)
        log("result", f"stdout={out.stdout.strip()} stderr={out.stderr.strip()} code={out.returncode}")
    except Exception as e:
        log("error", f"exec_failed: {e}")

    log_path.write_text(json.dumps(telemetry, indent=2))
    return log_path


