#!/usr/bin/env python3
"""
Exploit Failure Analyzer
Analyzes why exploits fail and suggests next steps
"""

import logging
import re
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

class ExploitAnalyzer:
    """Analyzes exploit execution results and provides actionable insights"""
    
    def __init__(self):
        self.failure_patterns = {
            'network': {
                'patterns': [
                    r'no route to host',
                    r'connection refused',
                    r'network unreachable',
                    r'errno 113',
                    r'errno 111',
                    r'timeout',
                    r'could not connect'
                ],
                'category': 'Network Connectivity',
                'severity': 'HIGH'
            },
            'authentication': {
                'patterns': [
                    r'access denied',
                    r'authentication failed',
                    r'invalid credentials',
                    r'permission denied'
                ],
                'category': 'Authentication',
                'severity': 'MEDIUM'
            },
            'patched': {
                'patterns': [
                    r'attack failed after maximum attempts',
                    r'appears patched',
                    r'no vulnerability detected',
                    r'target is probably patched'
                ],
                'category': 'Target Patched',
                'severity': 'INFO'
            },
            'configuration': {
                'patterns': [
                    r'unexpected error code',
                    r'incorrect dc name',
                    r'netlogon.*unavailable',
                    r'service.*stopped'
                ],
                'category': 'Configuration Issue',
                'severity': 'MEDIUM'
            }
        }
    
    def analyze_failure(self, exploit_result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze exploit failure and provide detailed insights
        
        Returns:
            Dict with analysis results and recommendations
        """
        output = exploit_result.get('execution_output', '').lower()
        
        analysis = {
            'failure_detected': not exploit_result.get('success', False),
            'failure_categories': [],
            'root_causes': [],
            'recommendations': [],
            'alternative_approaches': [],
            'confidence_score': 0.0,
            'requires_manual_review': False
        }
        
        if not analysis['failure_detected']:
            return analysis
        
        # Identify failure categories
        for failure_type, config in self.failure_patterns.items():
            for pattern in config['patterns']:
                if re.search(pattern, output, re.IGNORECASE):
                    analysis['failure_categories'].append({
                        'type': failure_type,
                        'category': config['category'],
                        'severity': config['severity'],
                        'pattern_matched': pattern
                    })
                    break
        
        # Generate root cause analysis
        analysis['root_causes'] = self._identify_root_causes(output, exploit_result)
        
        # Generate recommendations
        analysis['recommendations'] = self._generate_recommendations(
            analysis['failure_categories'],
            analysis['root_causes'],
            exploit_result
        )
        
        # Generate alternative approaches
        analysis['alternative_approaches'] = self._suggest_alternatives(
            analysis['failure_categories'],
            exploit_result
        )
        
        # Calculate confidence score
        analysis['confidence_score'] = self._calculate_confidence(
            analysis['failure_categories'],
            exploit_result
        )
        
        # Determine if manual review is needed
        analysis['requires_manual_review'] = (
            len(analysis['failure_categories']) == 0 or
            analysis['confidence_score'] < 0.7
        )
        
        return analysis
    
    def _identify_root_causes(self, output: str, exploit_result: Dict[str, Any]) -> List[str]:
        """Identify the root causes of failure"""
        causes = []
        
        # Network issues
        if any(p in output for p in ['no route', 'unreachable', 'timeout']):
            causes.append("Network connectivity issue between scanner and target")
            causes.append("Firewall may be blocking required ports (TCP 445, 135)")
        
        # Patched system
        if 'appears patched' in output or 'attack failed after' in output:
            causes.append("Target system has security updates installed (KB4565457)")
            causes.append("Netlogon secure channel protection is active")
        
        # Configuration
        if 'unexpected error' in output:
            causes.append("DC name may be incorrect (use NetBIOS name, not FQDN)")
            causes.append("Target may not be a Domain Controller")
        
        # Service issues
        if 'service' in output and 'unavailable' in output:
            causes.append("Netlogon service may be stopped on target")
            causes.append("RPC service may be unavailable")
        
        # Generic analysis
        attempts = exploit_result.get('attempts_made', 0)
        if attempts > 200:
            causes.append("High number of attempts suggests target is likely patched")
        elif attempts < 10:
            causes.append("Low number of attempts suggests connection or configuration issue")
        
        return causes if causes else ["Unable to determine specific root cause from output"]
    
    def _generate_recommendations(self, categories: List[Dict], causes: List[str], 
                                   exploit_result: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate actionable recommendations"""
        recommendations = []
        
        # Network recommendations
        if any(c['type'] == 'network' for c in categories):
            recommendations.append({
                'priority': 'HIGH',
                'category': 'Network',
                'action': 'Verify network connectivity',
                'steps': [
                    f"ping {exploit_result.get('target_ip', 'TARGET_IP')}",
                    f"nmap -p 445,135 {exploit_result.get('target_ip', 'TARGET_IP')}",
                    "Check firewall rules on both source and target",
                    "Verify you're on the same network segment"
                ]
            })
        
        # Patched system recommendations
        if any(c['type'] == 'patched' for c in categories):
            recommendations.append({
                'priority': 'INFO',
                'category': 'System Status',
                'action': 'System appears to be patched - This is GOOD',
                'steps': [
                    "Verify patch status: wmic qfe list | findstr KB4565457",
                    "Document this finding for compliance",
                    "Consider testing other CVEs",
                    "Move to next assessment phase"
                ]
            })
        
        # Configuration recommendations
        if any(c['type'] == 'configuration' for c in categories):
            recommendations.append({
                'priority': 'MEDIUM',
                'category': 'Configuration',
                'action': 'Verify target configuration',
                'steps': [
                    f"Confirm DC name is correct: {exploit_result.get('dc_name', 'DC_NAME')}",
                    "Use NetBIOS name, not FQDN (e.g., 'DC01' not 'dc01.domain.com')",
                    "Verify target is actually a Domain Controller",
                    "Check if Netlogon service is running on target"
                ]
            })
        
        # Alternative exploitation methods
        recommendations.append({
            'priority': 'MEDIUM',
            'category': 'Alternative Approaches',
            'action': 'Try alternative exploitation methods',
            'steps': [
                "Search for other vulnerabilities affecting this target",
                "Attempt different CVEs (e.g., PrintNightmare, PetitPotam)",
                "Use different exploitation parameters",
                "Consult with CrewAI agents for alternative strategies"
            ]
        })
        
        # Manual verification
        recommendations.append({
            'priority': 'LOW',
            'category': 'Verification',
            'action': 'Manual verification recommended',
            'steps': [
                "Review full execution output for additional clues",
                "Check Windows Event Logs on target (Event ID 5827, 5828)",
                "Verify target system version and patch level",
                "Consider alternative scanning tools for verification"
            ]
        })
        
        return recommendations
    
    def _suggest_alternatives(self, categories: List[Dict], 
                             exploit_result: Dict[str, Any]) -> List[Dict[str, str]]:
        """Suggest alternative exploitation approaches"""
        alternatives = []
        
        # If network issue
        if any(c['type'] == 'network' for c in categories):
            alternatives.append({
                'method': 'VPN Connection',
                'description': 'Establish VPN connection to target network',
                'difficulty': 'Easy',
                'likelihood': 'High'
            })
            alternatives.append({
                'method': 'Proxy/Relay',
                'description': 'Use intermediate host to reach target',
                'difficulty': 'Medium',
                'likelihood': 'Medium'
            })
        
        # If patched
        if any(c['type'] == 'patched' for c in categories):
            alternatives.append({
                'method': 'Different CVE',
                'description': 'Test for other vulnerabilities (PrintNightmare, PetitPotam, etc.)',
                'difficulty': 'Easy',
                'likelihood': 'Medium'
            })
            alternatives.append({
                'method': 'Social Engineering',
                'description': 'Attempt credential gathering through non-technical means',
                'difficulty': 'Hard',
                'likelihood': 'Variable'
            })
            alternatives.append({
                'method': 'Post-Auth Exploitation',
                'description': 'Obtain valid credentials first, then exploit authenticated vulnerabilities',
                'difficulty': 'Medium',
                'likelihood': 'Medium'
            })
        
        # If configuration issue
        if any(c['type'] == 'configuration' for c in categories):
            alternatives.append({
                'method': 'Target Enumeration',
                'description': 'Perform comprehensive enumeration to identify correct parameters',
                'difficulty': 'Easy',
                'likelihood': 'High'
            })
            alternatives.append({
                'method': 'Alternative DCs',
                'description': 'If multiple DCs exist, try targeting different ones',
                'difficulty': 'Easy',
                'likelihood': 'High'
            })
        
        # General alternatives
        alternatives.append({
            'method': 'Comprehensive Scan',
            'description': 'Run full vulnerability scan to identify all weaknesses',
            'difficulty': 'Easy',
            'likelihood': 'High'
        })
        
        alternatives.append({
            'method': 'Credential Attacks',
            'description': 'Password spraying, credential stuffing, or Kerberoasting',
            'difficulty': 'Medium',
            'likelihood': 'Medium'
        })
        
        return alternatives
    
    def _calculate_confidence(self, categories: List[Dict], 
                             exploit_result: Dict[str, Any]) -> float:
        """Calculate confidence in the analysis"""
        score = 0.0
        
        # Base score if we identified failure categories
        if len(categories) > 0:
            score += 0.5
        
        # Increase confidence if specific patterns matched
        if len(categories) >= 2:
            score += 0.2
        
        # Increase if we have execution output
        if exploit_result.get('execution_output'):
            score += 0.2
        
        # Increase if we have return code
        if exploit_result.get('return_code') is not None:
            score += 0.1
        
        return min(score, 1.0)
    
    def generate_report(self, analysis: Dict[str, Any], exploit_result: Dict[str, Any]) -> str:
        """Generate a detailed analysis report"""
        report = []
        report.append("=" * 80)
        report.append("EXPLOIT FAILURE ANALYSIS REPORT")
        report.append("=" * 80)
        report.append("")
        
        # Executive Summary
        report.append("[EXECUTIVE SUMMARY]")
        report.append(f"Target: {exploit_result.get('target_ip', 'Unknown')}")
        report.append(f"CVE: {exploit_result.get('cve_id', 'Unknown')}")
        report.append(f"Status: EXPLOIT FAILED")
        report.append(f"Confidence: {analysis['confidence_score'] * 100:.0f}%")
        report.append("")
        
        # Failure Categories
        if analysis['failure_categories']:
            report.append("[FAILURE CATEGORIES]")
            for cat in analysis['failure_categories']:
                report.append(f"  - {cat['category']} ({cat['severity']})")
            report.append("")
        
        # Root Causes
        if analysis['root_causes']:
            report.append("[ROOT CAUSE ANALYSIS]")
            for i, cause in enumerate(analysis['root_causes'], 1):
                report.append(f"  {i}. {cause}")
            report.append("")
        
        # Recommendations
        if analysis['recommendations']:
            report.append("[RECOMMENDATIONS]")
            for rec in analysis['recommendations']:
                report.append(f"\n  [{rec['priority']}] {rec['category']}: {rec['action']}")
                for step in rec['steps']:
                    report.append(f"    • {step}")
            report.append("")
        
        # Alternative Approaches
        if analysis['alternative_approaches']:
            report.append("[ALTERNATIVE EXPLOITATION METHODS]")
            for alt in analysis['alternative_approaches']:
                report.append(f"\n  • {alt['method']} (Difficulty: {alt['difficulty']}, Success: {alt['likelihood']})")
                report.append(f"    {alt['description']}")
            report.append("")
        
        # Next Steps
        report.append("[NEXT STEPS]")
        report.append("  1. Review the recommendations above in priority order")
        report.append("  2. Address any network or configuration issues")
        report.append("  3. If target is patched, document and move to next phase")
        report.append("  4. Consider alternative exploitation methods")
        report.append("  5. Consult with security team for additional strategies")
        report.append("")
        
        # Manual Review Flag
        if analysis['requires_manual_review']:
            report.append("[!] MANUAL REVIEW REQUIRED")
            report.append("    The automated analysis has low confidence.")
            report.append("    Please review the full execution output manually.")
            report.append("")
        
        report.append("=" * 80)
        
        return "\n".join(report)
