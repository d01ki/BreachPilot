import json
import subprocess
import tempfile
import os
import sys
from typing import Dict, Any, Optional
from pathlib import Path
from backend.models import ExploitResult, PoCResult, StepStatus
from backend.config import config
import logging

logger = logging.getLogger(__name__)

class ExploitExecutor:
    def __init__(self):
        self.sandbox_enabled = True
    
    def _check_environment(self) -> Dict[str, Any]:
        """Check environment for common dependency issues"""
        checks = {
            'cffi_version_check': False,
            'impacket_import': False,
            'cryptodome_import': False,
            'python_version': sys.version_info[:2],
            'issues': []
        }
        
        try:
            # Check cffi version compatibility
            import cffi
            cffi_version = cffi.__version__
            checks['cffi_version'] = cffi_version
            
            try:
                # Try to import _cffi_backend to check version compatibility
                import _cffi_backend
                backend_version = getattr(_cffi_backend, '__version__', 'unknown')
                checks['cffi_backend_version'] = backend_version
                
                if cffi_version != backend_version and backend_version != 'unknown':
                    checks['issues'].append(f"CFFI version mismatch: package {cffi_version} vs backend {backend_version}")
                else:
                    checks['cffi_version_check'] = True
                    
            except ImportError as e:
                checks['issues'].append(f"CFFI backend import failed: {e}")
                
        except ImportError as e:
            checks['issues'].append(f"CFFI import failed: {e}")
        
        # Test impacket import
        try:
            import impacket
            checks['impacket_import'] = True
            checks['impacket_version'] = getattr(impacket, '__version__', 'unknown')
        except ImportError as e:
            checks['issues'].append(f"Impacket import failed: {e}")
        except Exception as e:
            checks['issues'].append(f"Impacket compatibility issue: {e}")
        
        # Test Cryptodome import
        try:
            from Cryptodome.Cipher import ARC4
            checks['cryptodome_import'] = True
        except ImportError as e:
            checks['issues'].append(f"Cryptodome import failed: {e}")
        except Exception as e:
            checks['issues'].append(f"Cryptodome compatibility issue: {e}")
        
        return checks
    
    def _fix_cffi_environment(self):
        """Attempt to fix CFFI environment issues"""
        try:
            # Force reinstall cffi with compatible version
            subprocess.run([
                sys.executable, '-m', 'pip', 'install', 
                '--force-reinstall', '--no-deps', 'cffi>=1.16.0,<2.0.0'
            ], capture_output=True, timeout=60)
            
            # Reinstall pycryptodome to ensure compatibility
            subprocess.run([
                sys.executable, '-m', 'pip', 'install', 
                '--force-reinstall', 'pycryptodome>=3.19.0'
            ], capture_output=True, timeout=60)
            
            # Reinstall impacket
            subprocess.run([
                sys.executable, '-m', 'pip', 'install', 
                '--force-reinstall', 'impacket>=0.12.0'
            ], capture_output=True, timeout=60)
            
            logger.info("Dependency fix attempt completed")
            return True
            
        except Exception as e:
            logger.error(f"Failed to fix dependencies: {e}")
            return False
    
    def execute_exploit(self, target_ip: str, poc_result: PoCResult) -> ExploitResult:
        """Execute exploit in sandboxed environment"""
        logger.info(f"Executing exploit for {poc_result.cve_id} against {target_ip}")
        
        result = ExploitResult(
            cve_id=poc_result.cve_id,
            status=StepStatus.RUNNING
        )
        
        try:
            # Check environment before execution
            env_check = self._check_environment()
            logger.info(f"Environment check results: {env_check}")
            
            # If there are critical issues, attempt to fix them
            if env_check['issues'] and not env_check['impacket_import']:
                logger.warning(f"Environment issues detected: {env_check['issues']}")
                if self._fix_cffi_environment():
                    # Re-check environment after fix attempt
                    env_check = self._check_environment()
                    logger.info(f"Environment check after fix: {env_check}")
            
            if not poc_result.selected_poc:
                raise ValueError("No PoC selected for execution")
            
            poc = poc_result.selected_poc
            
            # Determine execution method based on PoC type
            if poc.get('type') == 'metasploit':
                result = self._execute_metasploit(target_ip, poc_result.cve_id, result)
            elif poc.get('type') == 'github':
                result = self._execute_github_poc(target_ip, poc, result)
            elif poc.get('type') == 'python':
                result = self._execute_python_script(target_ip, poc, result)
            else:
                result = self._execute_custom_poc(target_ip, poc, result)
            
            # Include environment info in result
            result.environment_info = env_check
            
            # Verify exploitation success
            result.success = self._verify_success(result.execution_output)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            
        except Exception as e:
            logger.error(f"Exploit execution failed: {e}")
            result.execution_output = str(e)
            result.success = False
            result.status = StepStatus.FAILED
            
            # Add environment info even on failure
            try:
                result.environment_info = self._check_environment()
            except:
                pass
        
        # Save result
        self._save_result(target_ip, result)
        return result
    
    def _execute_metasploit(self, target_ip: str, cve_id: str, result: ExploitResult) -> ExploitResult:
        """Execute Metasploit module"""
        logger.info(f"Executing Metasploit module for {cve_id}")
        
        try:
            # Create resource script for Metasploit
            rc_script = self._create_msf_resource_script(target_ip, cve_id)
            
            # Execute Metasploit
            cmd = [
                'msfconsole',
                '-q',
                '-r', rc_script
            ]
            
            result.exploit_command = ' '.join(cmd)
            
            # Run with timeout
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            result.execution_output = process.stdout + process.stderr
            
            # Extract evidence of success
            if 'session opened' in result.execution_output.lower():
                result.evidence.append("Meterpreter session established")
            
            # Cleanup
            os.remove(rc_script)
            
        except subprocess.TimeoutExpired:
            result.execution_output = "Execution timeout exceeded"
        except Exception as e:
            logger.error(f"Metasploit execution failed: {e}")
            result.execution_output = str(e)
        
        return result
    
    def _create_msf_resource_script(self, target_ip: str, cve_id: str) -> str:
        """Create Metasploit resource script dynamically based on CVE"""
        # Generic script - will search for appropriate module
        rc_content = f"""search {cve_id}
exit
"""
        
        # Write to temp file
        fd, rc_path = tempfile.mkstemp(suffix='.rc')
        with os.fdopen(fd, 'w') as f:
            f.write(rc_content)
        
        return rc_path
    
    def _execute_github_poc(self, target_ip: str, poc: Dict[str, Any], result: ExploitResult) -> ExploitResult:
        """Execute GitHub PoC"""
        logger.info(f"Executing GitHub PoC from {poc.get('url')}")
        
        try:
            # Clone repository
            repo_url = poc.get('url')
            repo_dir = tempfile.mkdtemp()
            
            # Clone
            clone_cmd = ['git', 'clone', repo_url, repo_dir]
            subprocess.run(clone_cmd, capture_output=True, timeout=60)
            
            # Look for exploit script
            exploit_script = self._find_exploit_script(repo_dir)
            
            if exploit_script:
                # Execute script with proper environment
                env = os.environ.copy()
                env['PYTHONPATH'] = os.pathsep.join([repo_dir] + env.get('PYTHONPATH', '').split(os.pathsep))
                
                if exploit_script.endswith('.py'):
                    cmd = [sys.executable, exploit_script, target_ip]
                elif exploit_script.endswith('.sh'):
                    cmd = ['bash', exploit_script, target_ip]
                else:
                    cmd = [exploit_script, target_ip]
                
                result.exploit_command = ' '.join(cmd)
                
                process = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=120,
                    cwd=repo_dir,
                    env=env
                )
                
                result.execution_output = process.stdout + process.stderr
            else:
                result.execution_output = "No executable exploit script found in repository"
            
            # Cleanup
            import shutil
            shutil.rmtree(repo_dir, ignore_errors=True)
            
        except Exception as e:
            logger.error(f"GitHub PoC execution failed: {e}")
            result.execution_output = str(e)
        
        return result
    
    def _find_exploit_script(self, repo_dir: str) -> Optional[str]:
        """Find main exploit script in repository"""
        common_names = [
            'exploit.py', 'poc.py', 'exploit.sh', 'poc.sh',
            'main.py', 'run.py', 'exploit'
        ]
        
        for name in common_names:
            script_path = Path(repo_dir) / name
            if script_path.exists():
                return str(script_path)
        
        # Search for Python files
        for py_file in Path(repo_dir).rglob('*.py'):
            if any(keyword in py_file.name.lower() for keyword in ['exploit', 'poc', 'main']):
                return str(py_file)
        
        return None
    
    def _execute_python_script(self, target_ip: str, poc: Dict[str, Any], result: ExploitResult) -> ExploitResult:
        """Execute Python script PoC"""
        logger.info("Executing Python script PoC")
        
        try:
            script_content = poc.get('script', '')
            
            if not script_content:
                raise ValueError("No script content provided")
            
            # Write script to temp file
            fd, script_path = tempfile.mkstemp(suffix='.py')
            with os.fdopen(fd, 'w') as f:
                f.write(script_content)
            
            # Execute with current Python interpreter
            cmd = [sys.executable, script_path, target_ip]
            result.exploit_command = ' '.join(cmd)
            
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            result.execution_output = process.stdout + process.stderr
            
            # Cleanup
            os.remove(script_path)
            
        except Exception as e:
            logger.error(f"Python script execution failed: {e}")
            result.execution_output = str(e)
        
        return result
    
    def _execute_custom_poc(self, target_ip: str, poc: Dict[str, Any], result: ExploitResult) -> ExploitResult:
        """Execute custom PoC"""
        logger.info("Executing custom PoC")
        
        result.execution_output = "Custom PoC execution not yet implemented"
        return result
    
    def _verify_success(self, output: str) -> bool:
        """Verify if exploitation was successful"""
        success_indicators = [
            'session opened',
            'shell spawned',
            'exploit successful',
            'connection established',
            'authentication bypassed',
            'root shell',
            'admin access'
        ]
        
        output_lower = output.lower()
        return any(indicator in output_lower for indicator in success_indicators)
    
    def _save_result(self, target_ip: str, result: ExploitResult):
        """Save exploit result to JSON"""
        output_file = config.DATA_DIR / f"{target_ip}_{result.cve_id}_exploit.json"
        with open(output_file, 'w') as f:
            json.dump(result.model_dump(), f, indent=2, default=str)
        logger.info(f"Exploit result saved to {output_file}")
