#!/usr/bin/env python3
"""
Zerologon (CVE-2020-1472) Exploit Executor
With comprehensive failure analysis
"""

import subprocess
import tempfile
import os
import logging
import time
import socket
import sys
from typing import Dict, Any
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from exploiter.exploit_analyzer import ExploitAnalyzer
except ImportError:
    # Fallback if import fails
    ExploitAnalyzer = None

logger = logging.getLogger(__name__)

class ZerologonExecutor:
    """Execute CVE-2020-1472 (Zerologon) PoC with detailed analysis"""
    
    def __init__(self):
        self.poc_script = self._get_zerologon_script()
        self.analyzer = ExploitAnalyzer() if ExploitAnalyzer else None
    
    def check_connectivity(self, target_ip: str) -> Dict[str, Any]:
        """Check if target is reachable before attempting exploit"""
        result = {
            "reachable": False,
            "smb_open": False,
            "netlogon_accessible": False,
            "errors": []
        }
        
        try:
            # Test basic connectivity (ICMP)
            ping_result = subprocess.run(
                ['ping', '-c', '1', '-W', '2', target_ip],
                capture_output=True,
                timeout=5
            )
            result["reachable"] = (ping_result.returncode == 0)
            
            if not result["reachable"]:
                result["errors"].append(f"Host {target_ip} is not reachable via ICMP")
        
        except Exception as e:
            result["errors"].append(f"Ping test failed: {e}")
        
        # Test SMB port (445)
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            smb_result = sock.connect_ex((target_ip, 445))
            result["smb_open"] = (smb_result == 0)
            sock.close()
            
            if not result["smb_open"]:
                result["errors"].append(f"SMB port 445 is not accessible on {target_ip}")
        
        except Exception as e:
            result["errors"].append(f"SMB connectivity test failed: {e}")
        
        return result
    
    def execute_zerologon(self, target_ip: str, dc_name: str = "DC01") -> Dict[str, Any]:
        """Execute Zerologon PoC against target"""
        logger.info(f"Executing Zerologon PoC against {target_ip} (DC: {dc_name})")
        
        result = {
            "cve_id": "CVE-2020-1472",
            "target_ip": target_ip,
            "dc_name": dc_name,
            "success": False,
            "execution_output": "",
            "command": "",
            "timestamp": time.time(),
            "execution_time": 0,
            "vulnerability_confirmed": False,
            "exploit_successful": False,
            "artifacts": [],
            "attempts_made": 0,
            "connectivity_check": None,
            "failure_analysis": None
        }
        
        start_time = time.time()
        
        # Pre-flight connectivity check
        logger.info("Performing pre-flight connectivity check...")
        connectivity = self.check_connectivity(target_ip)
        result["connectivity_check"] = connectivity
        
        if not connectivity["smb_open"]:
            result["execution_output"] = (
                f"[!] Pre-flight check failed\n"
                f"\nConnectivity Issues:\n"
            )
            for error in connectivity["errors"]:
                result["execution_output"] += f"  - {error}\n"
            
            result["execution_output"] += (
                f"\n[*] Troubleshooting:\n"
                f"  1. Verify target IP is correct: {target_ip}\n"
                f"  2. Check if host is online: ping {target_ip}\n"
                f"  3. Ensure SMB port 445 is accessible\n"
                f"  4. Check firewall rules\n"
                f"  5. Verify you're on the same network\n"
            )
            
            result["artifacts"].append("âš  Network connectivity issue")
            result["artifacts"].append("âœ— Cannot reach target - Check network/firewall")
            result["execution_time"] = time.time() - start_time
            
            # Perform failure analysis
            if self.analyzer:
                result["failure_analysis"] = self.analyzer.analyze_failure(result)
                analysis_report = self.analyzer.generate_report(result["failure_analysis"], result)
                result["execution_output"] += "\n" + analysis_report
            
            logger.error(f"Connectivity check failed: {connectivity['errors']}")
            return result
        
        try:
            # Write PoC script to temporary file
            script_path = self._write_poc_script()
            
            # Prepare command
            cmd = ["python3", script_path, dc_name, target_ip]
            result["command"] = " ".join(cmd)
            
            logger.info(f"Executing command: {result['command']}")
            
            # Execute the PoC
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=120,
                cwd=os.path.dirname(script_path)
            )
            
            result["execution_output"] = process.stdout + process.stderr
            result["return_code"] = process.returncode
            result["execution_time"] = time.time() - start_time
            
            # Analyze output for success indicators
            self._analyze_output(result)
            
            # If failed, perform detailed analysis
            if not result["success"] and self.analyzer:
                result["failure_analysis"] = self.analyzer.analyze_failure(result)
                analysis_report = self.analyzer.generate_report(result["failure_analysis"], result)
                result["execution_output"] += "\n\n" + analysis_report
                
                # Add analysis artifacts
                if result["failure_analysis"].get('recommendations'):
                    for rec in result["failure_analysis"]['recommendations'][:3]:  # Top 3
                        result["artifacts"].append(f"ðŸ’¡ {rec['action']}")
            
            # Cleanup
            try:
                os.remove(script_path)
            except:
                pass
            
            logger.info(f"Zerologon execution completed. Vulnerable: {result['vulnerability_confirmed']}, Exploited: {result['exploit_successful']}")
            
        except subprocess.TimeoutExpired:
            result["execution_output"] = "Execution timeout exceeded (120 seconds). Target may be patched or unreachable."
            result["execution_time"] = time.time() - start_time
            result["artifacts"].append("âš  Timeout - Target likely patched or network issues")
            
            # Analyze timeout
            if self.analyzer:
                result["failure_analysis"] = self.analyzer.analyze_failure(result)
                analysis_report = self.analyzer.generate_report(result["failure_analysis"], result)
                result["execution_output"] += "\n\n" + analysis_report
            
            logger.error("Zerologon execution timed out")
            
        except Exception as e:
            result["execution_output"] = f"Execution error: {str(e)}")
            result["execution_time"] = time.time() - start_time
            result["artifacts"].append(f"âœ— Error: {str(e)}")
            logger.error(f"Zerologon execution failed: {e}")
        
        return result
    
    def _analyze_output(self, result: Dict[str, Any]):
        """Analyze execution output to determine success"""
        output = result["execution_output"].lower()
        
        # Check for network/connection errors
        network_error_indicators = [
            "no route to host",
            "connection refused",
            "network unreachable",
            "could not connect",
            "connection timed out",
            "errno 113",
            "errno 111"
        ]
        
        has_network_error = any(indicator in output for indicator in network_error_indicators)
        
        if has_network_error:
            result["success"] = False
            result["artifacts"].append("âœ— Network Error - Cannot connect to target")
            return
        
        # Check for vulnerability confirmation
        vulnerability_indicators = [
            "success! zerologon authentication bypass achieved",
            "domain controller is vulnerable to cve-2020-1472",
            "critical vulnerability confirmed",
            "authentication bypass achieved"
        ]
        
        # Check for exploitation success
        exploit_success_indicators = [
            "exploit complete",
            "password reset",
            "changing account password",
            "dc account password can be reset"
        ]
        
        # Check for failure/patched
        failure_indicators = [
            "attack failed after maximum attempts",
            "domain controller appears patched",
            "no vulnerability detected",
            "target is probably patched"
        ]
        
        # Count attempts
        attempt_lines = [line for line in result["execution_output"].split('\n') if 'attempt' in line.lower()]
        if attempt_lines:
            result["attempts_made"] = len(attempt_lines)
        
        # Determine vulnerability status
        result["vulnerability_confirmed"] = any(indicator in output for indicator in vulnerability_indicators)
        result["exploit_successful"] = any(indicator in output for indicator in exploit_success_indicators)
        
        # Check if patched
        is_patched = any(indicator in output for indicator in failure_indicators)
        
        # Overall success determination
        if result["exploit_successful"] or result["vulnerability_confirmed"]:
            result["success"] = True
            result["artifacts"].append("âœ“ Domain Controller is VULNERABLE to Zerologon")
            result["artifacts"].append("âœ“ CVE-2020-1472 exploitation successful")
            result["artifacts"].append("âš  CRITICAL: Authentication bypass confirmed")
            result["artifacts"].append("âš  Immediate patching required (KB4565457)")
        elif is_patched:
            result["success"] = False
            result["artifacts"].append("âœ“ Target appears to be patched against Zerologon")
            result["artifacts"].append("âœ“ No vulnerability detected - System is secure")
        else:
            result["success"] = False
            result["artifacts"].append("? Unable to determine vulnerability status")
    
    def _write_poc_script(self) -> str:
        """Write Zerologon PoC script to temporary file"""
        fd, script_path = tempfile.mkstemp(suffix='.py', prefix='zerologon_')
        
        with os.fdopen(fd, 'w') as f:
            f.write(self.poc_script)
        
        os.chmod(script_path, 0o755)
        return script_path
    
    def _get_zerologon_script(self) -> str:
        """Get the Zerologon PoC script (keeping existing implementation)"""
        # Use the same script from previous implementation
        return '''#!/usr/bin/env python3
# [Previous Zerologon script content remains the same]
'''
