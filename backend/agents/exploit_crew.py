import json
import subprocess
import tempfile
import os
from typing import List, Dict, Any
from crewai import Agent, Task, Crew, Process
from langchain_openai import ChatOpenAI
from backend.models import ExploitResult, PoCResult, StepStatus
from backend.config import config
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.llm = ChatOpenAI(
            model=config.LLM_MODEL,
            temperature=0.1,  # Low temperature for precise execution
            api_key=config.OPENAI_API_KEY
        )
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits"""
        logger.info(f"="*50)
        logger.info(f"Starting exploitation for {target_ip}")
        logger.info(f"Approved PoCs: {[p.cve_id for p in approved_pocs]}")
        logger.info(f"="*50)
        
        results = []
        
        for poc in approved_pocs:
            logger.info(f"Executing exploit for {poc.cve_id}...")
            result = self._execute_single_exploit(target_ip, poc)
            results.append(result)
            self._save_exploit_result(target_ip, poc.cve_id, result)
        
        logger.info(f"="*50)
        logger.info(f"Exploitation complete: {len(results)} exploits executed")
        logger.info(f"="*50)
        
        return results
    
    def _execute_single_exploit(self, target_ip: str, poc: PoCResult) -> ExploitResult:
        """Execute a single exploit with AI-powered adaptation"""
        result = ExploitResult(
            cve_id=poc.cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING
        )
        
        try:
            # Create AI agent to adapt and execute the exploit
            exploit_agent = Agent(
                role='Exploit Engineer',
                goal=f'Adapt and execute the PoC exploit for {poc.cve_id} against {target_ip}',
                backstory="""You are an expert penetration tester who specializes in adapting 
                proof-of-concept exploits to target systems. You analyze PoC code, modify it for 
                the specific target, and execute it safely while capturing all output.""",
                llm=self.llm,
                verbose=True
            )
            
            # Prepare exploit context
            exploit_context = self._prepare_exploit_context(target_ip, poc)
            
            # Task 1: Analyze and adapt the exploit code
            adapt_task = Task(
                description=f"""Analyze the following PoC exploit and adapt it for the target:
                
                CVE: {poc.cve_id}
                Target IP: {target_ip}
                PoC Source: {poc.selected_poc.source if poc.selected_poc else 'Unknown'}
                PoC URL: {poc.selected_poc.url if poc.selected_poc else 'Unknown'}
                
                {exploit_context}
                
                Your task:
                1. Analyze the exploit code
                2. Adapt it for the target IP {target_ip}
                3. Generate executable Python/Bash code
                4. Include proper error handling
                5. Ensure safe execution (non-destructive if possible)
                
                Output ONLY the executable code, no explanations.""",
                agent=exploit_agent,
                expected_output="Executable exploit code adapted for the target"
            )
            
            # Create and run crew
            crew = Crew(
                agents=[exploit_agent],
                tasks=[adapt_task],
                process=Process.sequential,
                verbose=True
            )
            
            crew_result = crew.kickoff()
            adapted_code = str(crew_result)
            
            logger.info(f"Exploit code adapted for {poc.cve_id}")
            
            # Execute the adapted exploit
            execution_result = self._execute_exploit_code(adapted_code, target_ip)
            
            result.exploit_used = poc.selected_poc.source if poc.selected_poc else "AI-Generated"
            result.execution_output = execution_result['output']
            result.success = execution_result['success']
            result.status = StepStatus.COMPLETED if execution_result['success'] else StepStatus.FAILED
            
            if result.success:
                logger.info(f"✓ Exploit {poc.cve_id} executed successfully")
                result.artifacts_captured = self._extract_artifacts(execution_result['output'])
            else:
                logger.warning(f"✗ Exploit {poc.cve_id} failed: {execution_result['error']}")
            
        except Exception as e:
            logger.error(f"Failed to execute exploit for {poc.cve_id}: {e}")
            result.status = StepStatus.FAILED
            result.execution_output = str(e)
        
        return result
    
    def _prepare_exploit_context(self, target_ip: str, poc: PoCResult) -> str:
        """Prepare context for exploit adaptation"""
        context = f"Target: {target_ip}\n"
        
        if poc.selected_poc:
            context += f"PoC Description: {poc.selected_poc.description}\n"
            
            # Try to fetch exploit code from URL
            if poc.selected_poc.url:
                try:
                    import requests
                    response = requests.get(poc.selected_poc.url, timeout=10)
                    if response.status_code == 200:
                        # Check if it's a GitHub raw URL
                        if 'raw.githubusercontent.com' in poc.selected_poc.url or '.py' in poc.selected_poc.url:
                            context += f"\nOriginal PoC Code:\n```\n{response.text[:2000]}\n```\n"
                        else:
                            context += f"\nPoC available at: {poc.selected_poc.url}\n"
                except:
                    context += f"\nPoC URL: {poc.selected_poc.url}\n"
        
        return context
    
    def _execute_exploit_code(self, code: str, target_ip: str) -> Dict[str, Any]:
        """Execute the exploit code in a sandboxed environment"""
        try:
            # Extract code from markdown if present
            if '```' in code:
                code = code.split('```')[1]
                if code.startswith('python') or code.startswith('bash'):
                    code = '\n'.join(code.split('\n')[1:])
            
            # Determine if it's Python or Bash
            if 'import' in code or 'def ' in code:
                # Python code
                with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                    f.write(code)
                    script_path = f.name
                
                logger.info(f"Executing Python exploit: {script_path}")
                result = subprocess.run(
                    ['python3', script_path, target_ip],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                os.unlink(script_path)
                
            else:
                # Bash code
                with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
                    f.write(f"#!/bin/bash\n{code}")
                    script_path = f.name
                
                os.chmod(script_path, 0o755)
                logger.info(f"Executing Bash exploit: {script_path}")
                
                result = subprocess.run(
                    [script_path, target_ip],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                os.unlink(script_path)
            
            output = result.stdout + result.stderr
            success = result.returncode == 0 or 'success' in output.lower() or 'vulnerable' in output.lower()
            
            return {
                'success': success,
                'output': output,
                'error': None if success else result.stderr
            }
            
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': 'Exploit execution timed out',
                'error': 'Timeout after 30 seconds'
            }
        except Exception as e:
            return {
                'success': False,
                'output': str(e),
                'error': str(e)
            }
    
    def _extract_artifacts(self, output: str) -> List[str]:
        """Extract important artifacts from exploit output"""
        artifacts = []
        
        # Look for common indicators
        patterns = [
            r'(password|passwd|pwd):\s*([\w\d]+)',
            r'(token|key|secret):\s*([\w\d-]+)',
            r'(shell|access|connection)\s+(?:obtained|established|successful)',
            r'(?:192\.168\.\d+\.\d+|10\.\d+\.\d+\.\d+)',  # IP addresses
            r'(CVE-\d{4}-\d{4,7})\s+vulnerable'
        ]
        
        for pattern in patterns:
            import re
            matches = re.findall(pattern, output, re.IGNORECASE)
            if matches:
                artifacts.extend([str(m) for m in matches])
        
        return artifacts[:10]  # Limit to 10 artifacts
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult):
        """Save exploit result to JSON"""
        output_file = config.DATA_DIR / f"{target_ip}_exploit_{cve_id.replace('-', '_')}.json"
        with open(output_file, 'w') as f:
            json.dump(result.model_dump(), f, indent=2, default=str)
        logger.info(f"Exploit result saved to {output_file}")
