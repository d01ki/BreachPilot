import json
import os
import time
from typing import List, Dict, Any
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
from backend.utils.autonomous_git_executor import AutonomousGitPoCExecutor
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.autonomous_executor = AutonomousGitPoCExecutor()
        logger.info(f"ExploitCrew initialized with autonomous git executor")
        logger.info(f"Clone location: {self.autonomous_executor.get_clone_location()}")
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs using autonomous git clone approach"""
        logger.info(f"üöÄ Starting autonomous exploit execution for {cve_id} on {target_ip}")
        logger.info(f"Available PoCs: {len(poc_result.available_pocs)}")
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                logger.info("‚úÖ Success already achieved, skipping remaining PoCs")
                break
            
            logger.info(f"üéØ Attempting PoC #{i}: {poc.source} - {poc.url}")
            result = self._execute_single_poc_autonomous(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                logger.info(f"üéâ SUCCESS: PoC #{i} succeeded using autonomous execution!")
                success_achieved = True
                
                # Log success details
                if hasattr(result, 'autonomous_info') and result.autonomous_info:
                    info = result.autonomous_info
                    logger.info(f"  Successful Strategy: {info.get('successful_strategy', 'unknown')}")
                    logger.info(f"  Attempts Needed: {info.get('attempts_needed', 'unknown')}")
                    logger.info(f"  Clone Location: {info.get('clone_location', 'unknown')}")
            else:
                logger.warning(f"‚ùå FAILED: PoC #{i} - {result.failure_reason}")
                
                # Log failure details if available
                if hasattr(result, 'autonomous_info') and result.autonomous_info:
                    info = result.autonomous_info
                    strategies_tried = info.get('strategies_tried', [])
                    logger.warning(f"  Strategies Tried: {', '.join(strategies_tried)}")
                
                if i < len(poc_result.available_pocs):
                    logger.info(f"‚è≥ Waiting 2 seconds before next attempt...")
                    time.sleep(2)
        
        success_message = "SUCCESS" if success_achieved else "ALL FAILED"
        logger.info(f"üèÅ Autonomous exploit execution complete: {success_message}")
        
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with autonomous retry logic"""
        logger.info(f"üöÄ Executing {len(approved_pocs)} CVEs with autonomous system")
        
        all_results = []
        for i, poc_result in enumerate(approved_pocs, 1):
            logger.info(f"üìã CVE #{i}/{len(approved_pocs)}: {poc_result.cve_id}")
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
            
            # Brief pause between CVEs
            if i < len(approved_pocs):
                time.sleep(3)
        
        return all_results
    
    def _execute_single_poc_autonomous(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute a single PoC using autonomous approach"""
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url
        )
        
        start_time = time.time()
        
        try:
            # Determine execution approach
            if self._is_github_url(poc.url):
                logger.info(f"ü§ñ Executing GitHub PoC via autonomous git clone: {poc.url}")
                execution_result = self.autonomous_executor.execute_github_poc_with_autonomy(
                    poc.url, target_ip, cve_id
                )
                result.exploit_used = f"Autonomous Git Clone: {poc.url}"
            
            # Fallback to direct code execution
            elif poc.code and poc.code.strip():
                logger.info(f"üìù Executing PoC code directly (fallback)")
                execution_result = self._execute_poc_code_fallback(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct code execution: {poc.source}"
            
            # Try to fetch and execute from URL
            else:
                logger.info(f"üåê Attempting to fetch and execute from URL: {poc.url}")
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Process execution results
            result.execution_output = execution_result.get('output', '')
            result.success = execution_result.get('success', False)
            result.execution_time = round(time.time() - start_time, 2)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            result.return_code = execution_result.get('return_code', -1)
            
            # Store autonomous execution info
            if 'autonomous_execution_info' in execution_result:
                result.autonomous_info = execution_result['autonomous_execution_info']
            
            # Enhanced success analysis
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output)
                result.success_indicators = self._identify_success_indicators(result.execution_output)
                
                if result.artifacts_captured:
                    logger.info(f"  üéØ Artifacts captured: {len(result.artifacts_captured)} items")
                
                # Log autonomous execution details
                if hasattr(result, 'autonomous_info') and result.autonomous_info:
                    autonomous_info = result.autonomous_info
                    if 'successful_strategy' in autonomous_info:
                        logger.info(f"  üß† Successful Strategy: {autonomous_info['successful_strategy']}")
                    if 'clone_location' in autonomous_info:
                        logger.info(f"  üìÅ Clone Location: {autonomous_info['clone_location']}")
                    
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
                
                # Enhanced failure logging for autonomous execution
                if hasattr(result, 'autonomous_info') and result.autonomous_info:
                    autonomous_info = result.autonomous_info
                    if 'strategies_tried' in autonomous_info:
                        logger.debug(f"  üîÑ Strategies Attempted: {autonomous_info['strategies_tried']}")
                    if 'failed_attempts' in autonomous_info:
                        logger.debug(f"  ‚ùå Total Failures: {len(autonomous_info['failed_attempts'])}")
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Autonomous execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            logger.error(f"üí• PoC #{poc_index} autonomous execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        return result
    
    def _is_github_url(self, url: str) -> bool:
        """Check if URL is a GitHub repository URL"""
        if not url:
            return False
        
        github_patterns = [
            'github.com',
            'raw.githubusercontent.com'
        ]
        
        url_lower = url.lower()
        is_github = any(pattern in url_lower for pattern in github_patterns)
        
        # Exclude direct file URLs as they should be handled differently
        is_direct_file = any(ext in url_lower for ext in ['.py', '.sh', '.rb', '.pl', '.c', '.cpp'])
        
        return is_github and not is_direct_file
    
    def _execute_poc_code_fallback(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fallback method for executing PoC code directly"""
        try:
            import tempfile
            
            # Create temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp_file:
                # Simple wrapper for the code
                wrapped_code = f"""#!/usr/bin/env python3
import sys
target_ip = "{target_ip}" if len(sys.argv) <= 1 else sys.argv[1]

{code}
"""
                tmp_file.write(wrapped_code)
                tmp_file.flush()
                
                # Make executable
                os.chmod(tmp_file.name, 0o755)
                
                # Execute
                import subprocess
                result = subprocess.run(
                    ['python3', tmp_file.name, target_ip],
                    capture_output=True,
                    text=True,
                    timeout=120
                )
                
                # Clean up
                try:
                    os.unlink(tmp_file.name)
                except:
                    pass
                
                output = result.stdout + result.stderr
                success = self._analyze_execution_success(output, result.returncode)
                
                return {
                    'success': success,
                    'output': output,
                    'error': result.stderr if not success else None,
                    'return_code': result.returncode
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'Fallback execution error: {str(e)}',
                'error': str(e),
                'return_code': -1
            }
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute"""
        try:
            import requests
            import tempfile
            
            headers = {'User-Agent': 'Mozilla/5.0 (compatible; BreachPilot)'}
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                content = response.text
                
                # Determine file type and create temporary file
                if any(ext in url.lower() for ext in ['.py']):
                    suffix = '.py'
                    interpreter = ['python3']
                elif any(ext in url.lower() for ext in ['.sh']):
                    suffix = '.sh'
                    interpreter = ['bash']
                elif any(ext in url.lower() for ext in ['.rb']):
                    suffix = '.rb'
                    interpreter = ['ruby']
                elif any(ext in url.lower() for ext in ['.pl']):
                    suffix = '.pl'
                    interpreter = ['perl']
                else:
                    # Default to python
                    suffix = '.py'
                    interpreter = ['python3']
                
                # Create and execute temporary file
                with tempfile.NamedTemporaryFile(mode='w', suffix=suffix, delete=False) as tmp_file:
                    tmp_file.write(content)
                    tmp_file.flush()
                    
                    os.chmod(tmp_file.name, 0o755)
                    
                    import subprocess
                    result = subprocess.run(
                        interpreter + [tmp_file.name, target_ip],
                        capture_output=True,
                        text=True,
                        timeout=120
                    )
                    
                    # Clean up
                    try:
                        os.unlink(tmp_file.name)
                    except:
                        pass
                    
                    output = result.stdout + result.stderr
                    success = self._analyze_execution_success(output, result.returncode)
                    
                    return {
                        'success': success,
                        'output': output,
                        'error': result.stderr if not success else None,
                        'return_code': result.returncode
                    }
            else:
                return {
                    'success': False,
                    'output': f'Failed to fetch from URL: {url} (HTTP {response.status_code})',
                    'error': f'HTTP {response.status_code}',
                    'return_code': -1
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'URL fetch error: {str(e)}',
                'error': str(e),
                'return_code': -1
            }
    
    def _analyze_execution_success(self, output: str, return_code: int) -> bool:
        """Analyze if execution was successful"""
        output_lower = output.lower()
        
        # Strong success indicators
        success_indicators = [
            'exploit successful', 'successfully exploited', 'shell obtained',
            'access granted', 'vulnerability confirmed', 'target vulnerable',
            'privilege escalation', 'authentication bypassed', 'payload executed',
            'exploit completed', 'attack successful'
        ]
        
        # Failure indicators
        failure_indicators = [
            'failed', 'error', 'exception', 'not vulnerable',
            'access denied', 'connection refused', 'timeout',
            'traceback', 'syntax error', 'import error'
        ]
        
        # Check for explicit success messages
        if any(indicator in output_lower for indicator in success_indicators):
            return True
        
        # Check for explicit failure messages
        if any(indicator in output_lower for indicator in failure_indicators):
            return False
        
        # If return code is 0 and there's substantial output, consider success
        if return_code == 0 and len(output.strip()) > 20:
            return True
        
        return False
    
    def _extract_artifacts_enhanced(self, output: str) -> List[str]:
        """Extract security artifacts from exploit output"""
        artifacts = []
        import re
        
        patterns = [
            r'password[:\s]+([^\s\n]+)',
            r'username[:\s]+([^\s\n]+)',
            r'hash[:\s]+([a-f0-9]{32,})',
            r'token[:\s]+([^\s\n]+)',
            r'session[:\s]+([^\s\n]+)',
            r'cookie[:\s]+([^\s\n]+)',
            r'credential[s]?[:\s]+([^\n]+)',
            r'secret[:\s]+([^\s\n]+)',
            r'flag[:\s]+([^\s\n]+)',
            r'shell[:\s]+([^\s\n]+)'
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, output, re.IGNORECASE)
            for match in matches:
                artifact_type = pattern.split('[')[0]
                artifacts.append(f"{artifact_type}: {match.group(1)}")
        
        return list(set(artifacts))[:15]  # Limit to 15 unique artifacts
    
    def _identify_success_indicators(self, output: str) -> List[str]:
        """Identify success indicators from exploit output"""
        indicators = []
        success_patterns = [
            'exploit successful', 'shell obtained', 'access granted', 'login successful',
            'authentication bypassed', 'privilege escalation', 'root access', 'admin access',
            'payload executed', 'code execution', 'vulnerability confirmed', 'target vulnerable',
            'attack completed', 'exploitation successful'
        ]
        
        output_lower = output.lower()
        for pattern in success_patterns:
            if pattern in output_lower:
                indicators.append(pattern.title())
        
        return indicators[:8]  # Limit to 8 indicators
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result to file"""
        try:
            filename = f"{target_ip}_exploit_{cve_id}_{poc_index}.json"
            filepath = config.DATA_DIR / filename
            
            # Convert result to dict and handle autonomous info
            result_dict = result.dict()
            
            with open(filepath, 'w') as f:
                json.dump(result_dict, f, indent=2, default=str)
                
            logger.debug(f"üíæ Exploit result saved: {filename}")
        except Exception as e:
            logger.warning(f"Failed to save exploit result: {e}")
    
    def get_clone_location(self) -> str:
        """Get the clone location from autonomous executor"""
        return self.autonomous_executor.get_clone_location()
    
    def get_execution_statistics(self) -> Dict[str, Any]:
        """Get execution statistics from autonomous executor"""
        return {
            'clone_location': self.get_clone_location(),
            'total_executions': len(self.autonomous_executor.execution_history),
            'successful_strategies': [
                history['strategy'] for history in self.autonomous_executor.execution_history 
                if history['success']
            ],
            'failed_strategies': [
                history['strategy'] for history in self.autonomous_executor.execution_history 
                if not history['success']
            ]
        }
    
    def cleanup(self):
        """Clean up resources and temporary files"""
        logger.info("üßπ Cleaning up ExploitCrew resources...")
        try:
            if hasattr(self, 'autonomous_executor'):
                self.autonomous_executor.cleanup()
                logger.info("‚úÖ Autonomous executor cleanup completed")
        except Exception as e:
            logger.warning(f"Cleanup warning: {e}")
    
    def __del__(self):
        """Ensure cleanup on destruction"""
        try:
            self.cleanup()
        except:
            pass
