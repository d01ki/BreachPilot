import json
import os
import time
import subprocess
import tempfile
import re
from typing import List, Dict, Any
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
from backend.utils.git_poc_executor import GitPoCExecutor
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.git_executor = GitPoCExecutor()
        logger.info("ExploitCrew initialized with enhanced git clone executor")
    
    def execute_single_poc_enhanced(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute single PoC with enhanced success detection and autonomous dependency handling"""
        logger.info(f"üöÄ Executing PoC #{poc_index} for {cve_id}: {poc.source} - {poc.url}")
        
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url,
            timestamp=time.time()
        )
        
        start_time = time.time()
        
        try:
            # Choose execution method based on PoC type
            if self._is_github_url(poc.url):
                logger.info(f"Executing GitHub PoC via git clone: {poc.url}")
                execution_result = self.git_executor.execute_github_poc(poc.url, target_ip, cve_id)
                result.exploit_used = f"Git clone: {poc.url}"
                
            elif poc.code and poc.code.strip():
                logger.info(f"Executing PoC code directly")
                execution_result = self._execute_poc_code_enhanced(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct code execution: {poc.source}"
                
            else:
                logger.info(f"Attempting to fetch and execute from URL: {poc.url}")
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Enhanced result processing
            result.execution_output = execution_result.get('output', '')
            result.execution_command = execution_result.get('command', '')
            result.execution_time = round(time.time() - start_time, 2)
            result.return_code = execution_result.get('return_code', -1)
            
            # Enhanced success analysis
            result.success = self._analyze_execution_success_enhanced(result.execution_output, result.return_code, cve_id)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output, cve_id)
                result.success_indicators = self._identify_success_indicators_enhanced(result.execution_output, cve_id)
                result.vulnerability_confirmed = True
                result.exploit_successful = True
                
                logger.info(f"‚úÖ SUCCESS: PoC #{poc_index} executed successfully!")
                if result.artifacts_captured:
                    logger.info(f"  üéØ Artifacts captured: {result.artifacts_captured}")
                if result.success_indicators:
                    logger.info(f"  ‚úì Success indicators: {result.success_indicators}")
                    
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
                result.vulnerability_confirmed = False
                result.exploit_successful = False
                logger.warning(f"‚ùå FAILED: PoC #{poc_index} - {result.failure_reason}")
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            result.success = False
            logger.error(f"PoC #{poc_index} execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        return result
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs using enhanced approach"""
        logger.info(f"Starting enhanced exploit execution for {cve_id} on {target_ip} ({len(poc_result.available_pocs)} PoCs)")
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                logger.info("Success already achieved, skipping remaining PoCs")
                break
            
            result = self.execute_single_poc_enhanced(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                success_achieved = True
            else:
                if i < len(poc_result.available_pocs):
                    time.sleep(2)
        
        logger.info(f"Enhanced exploit execution complete: {'SUCCESS' if success_achieved else 'ALL FAILED'}")
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with enhanced retry logic"""
        all_results = []
        for poc_result in approved_pocs:
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
        return all_results
    
    def _is_github_url(self, url: str) -> bool:
        """Check if URL is a GitHub repository URL"""
        if not url:
            return False
        
        github_patterns = ['github.com', 'raw.githubusercontent.com']
        url_lower = url.lower()
        is_github = any(pattern in url_lower for pattern in github_patterns)
        
        # Exclude direct file URLs as they should be handled differently
        is_direct_file = any(ext in url_lower for ext in ['.py', '.sh', '.rb', '.pl', '.c', '.cpp'])
        
        return is_github and not is_direct_file
    
    def _analyze_dependencies(self, code: str) -> List[str]:
        """Analyze code to detect required dependencies"""
        dependencies = []
        
        # Python imports
        python_imports = re.findall(r'import\s+([a-zA-Z_][a-zA-Z0-9_]*)', code)
        python_from_imports = re.findall(r'from\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+import', code)
        
        all_imports = python_imports + python_from_imports
        
        # Common third-party packages that often need installation
        common_packages = {
            'pyfiglet': 'pyfiglet',
            'requests': 'requests',
            'paramiko': 'paramiko',
            'impacket': 'impacket',
            'ldap3': 'ldap3',
            'pycrypto': 'pycrypto',
            'cryptography': 'cryptography',
            'scapy': 'scapy',
            'numpy': 'numpy',
            'socket': None,  # Built-in
            'sys': None,     # Built-in
            'os': None,      # Built-in
            'time': None,    # Built-in
            'datetime': None,# Built-in
            'json': None,    # Built-in
            'base64': None,  # Built-in
            'hashlib': None, # Built-in
            'struct': None,  # Built-in
            'binascii': None,# Built-in
            'socket': None,  # Built-in
            'subprocess': None, # Built-in
            'threading': None,  # Built-in
            'ssl': None,     # Built-in
        }
        
        for import_name in all_imports:
            if import_name in common_packages and common_packages[import_name] is not None:
                dependencies.append(common_packages[import_name])
        
        return list(set(dependencies))
    
    def _install_dependencies(self, dependencies: List[str]) -> Dict[str, bool]:
        """Autonomously install required dependencies"""
        installation_results = {}
        
        for dep in dependencies:
            logger.info(f"üîß Auto-installing dependency: {dep}")
            try:
                result = subprocess.run(
                    ['pip', 'install', dep],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode == 0:
                    installation_results[dep] = True
                    logger.info(f"‚úÖ Successfully installed {dep}")
                else:
                    installation_results[dep] = False
                    logger.warning(f"‚ùå Failed to install {dep}: {result.stderr}")
                    
            except subprocess.TimeoutExpired:
                installation_results[dep] = False
                logger.warning(f"‚ùå Timeout installing {dep}")
            except Exception as e:
                installation_results[dep] = False
                logger.warning(f"‚ùå Error installing {dep}: {e}")
        
        return installation_results
    
    def _execute_poc_code_enhanced(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Enhanced method for executing PoC code with autonomous dependency management"""
        try:
            # Analyze dependencies first
            dependencies = self._analyze_dependencies(code)
            installation_log = []
            
            if dependencies:
                logger.info(f"üîç Detected dependencies: {dependencies}")
                installation_log.append(f"Detected dependencies: {', '.join(dependencies)}")
                
                # Attempt to install dependencies
                install_results = self._install_dependencies(dependencies)
                
                failed_deps = [dep for dep, success in install_results.items() if not success]
                if failed_deps:
                    logger.warning(f"‚ö†Ô∏è Some dependencies failed to install: {failed_deps}")
                    installation_log.append(f"Failed to install: {', '.join(failed_deps)}")
                else:
                    logger.info("‚úÖ All dependencies installed successfully")
                    installation_log.append("All dependencies installed successfully")
            
            # Determine script type
            if code.startswith('#!/usr/bin/env python') or 'import ' in code[:300]:
                interpreter = 'python3'
                suffix = '.py'
            elif code.startswith('#!/bin/bash') or code.startswith('#!/bin/sh'):
                interpreter = 'bash'
                suffix = '.sh'
            elif code.startswith('#!/usr/bin/ruby') or 'require ' in code[:200]:
                interpreter = 'ruby'
                suffix = '.rb'
            elif '#include' in code[:200]:
                interpreter = 'gcc'
                suffix = '.c'
            else:
                interpreter = 'python3'
                suffix = '.py'
            
            # Create temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix=suffix, delete=False) as tmp_file:
                if interpreter == 'python3' and not code.startswith('#!'):
                    # Add enhanced wrapper for Python scripts
                    wrapped_code = f"""#!/usr/bin/env python3
import sys
import os

# Handle target IP argument
target_ip = "{target_ip}"
if len(sys.argv) > 1:
    target_ip = sys.argv[1]

# CVE ID for reference
cve_id = "{cve_id}"

# Autonomous dependency installation log
print("=== BreachPilot Autonomous Execution ===")
{chr(10).join([f'print("{log}")' for log in installation_log])}
print("==========================================")

# Original PoC code below:
try:
{chr(10).join(['    ' + line for line in code.split(chr(10))])}
except ImportError as e:
    print(f"‚ùå Missing dependency: {{e}}")
    print("BreachPilot attempted autonomous installation but some packages may require manual setup.")
    sys.exit(1)
except Exception as e:
    print(f"Execution error: {{e}}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
"""
                    tmp_file.write(wrapped_code)
                else:
                    tmp_file.write(code)
                
                tmp_file.flush()
                os.chmod(tmp_file.name, 0o755)
                
                # Execute based on interpreter
                if interpreter == 'gcc':
                    # Compile C code first
                    executable = tmp_file.name.replace('.c', '')
                    compile_result = subprocess.run(
                        ['gcc', '-o', executable, tmp_file.name],
                        capture_output=True,
                        text=True,
                        timeout=30
                    )
                    
                    if compile_result.returncode == 0:
                        cmd = [executable, target_ip]
                    else:
                        return {
                            'success': False,
                            'output': f'Compilation failed: {compile_result.stderr}',
                            'error': 'Compilation error',
                            'return_code': compile_result.returncode,
                            'command': f'gcc -o {executable} {tmp_file.name}'
                        }
                else:
                    cmd = [interpreter, tmp_file.name, target_ip]
                
                # Execute the script with enhanced environment
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=180,  # 3 minute timeout
                    env=self._get_secure_env()
                )
                
                # Cleanup
                try:
                    os.unlink(tmp_file.name)
                    if interpreter == 'gcc' and 'executable' in locals():
                        os.unlink(executable)
                except:
                    pass
                
                output = result.stdout + result.stderr
                
                # Add dependency installation info to output
                if installation_log:
                    output = f"Dependency Installation:\n{chr(10).join(installation_log)}\n\n" + output
                
                success = self._analyze_execution_success_enhanced(output, result.returncode, cve_id)
                
                return {
                    'success': success,
                    'output': output,
                    'error': result.stderr if not success else None,
                    'return_code': result.returncode,
                    'command': ' '.join(cmd),
                    'dependencies_installed': len([d for d in dependencies if d]) if dependencies else 0
                }
                
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': 'Execution timeout exceeded (180 seconds)',
                'error': 'Timeout',
                'return_code': -1,
                'command': ' '.join(cmd) if 'cmd' in locals() else 'Unknown'
            }
        except Exception as e:
            return {
                'success': False,
                'output': f'Enhanced execution error: {str(e)}',
                'error': str(e),
                'return_code': -1,
                'command': 'Error during setup'
            }
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute with enhancements"""
        try:
            import requests
            
            headers = {'User-Agent': 'Mozilla/5.0 (compatible; BreachPilot)'}
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                content = response.text
                
                # Determine file type and execute
                return self._execute_poc_code_enhanced(content, target_ip, cve_id, poc_index)
            else:
                return {
                    'success': False,
                    'output': f'Failed to fetch from URL: {url} (HTTP {response.status_code})',
                    'error': f'HTTP {response.status_code}',
                    'return_code': -1,
                    'command': f'curl {url}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'URL fetch error: {str(e)}',
                'error': str(e),
                'return_code': -1,
                'command': f'curl {url}'
            }
    
    def _analyze_execution_success_enhanced(self, output: str, return_code: int, cve_id: str) -> bool:
        """Enhanced analysis to determine if execution was successful"""
        output_lower = output.lower()
        
        # General success indicators
        general_success_indicators = [
            'exploit successful', 'successfully exploited', 'shell obtained',
            'access granted', 'vulnerability confirmed', 'target vulnerable',
            'privilege escalation', 'authentication bypassed', 'payload executed',
            'exploit complete', 'pwned', 'compromised', 'backdoor installed',
            'reverse shell', 'meterpreter session', 'command executed'
        ]
        
        # Check general indicators
        if any(indicator in output_lower for indicator in general_success_indicators):
            return True
        
        # Check for failure indicators
        failure_indicators = [
            'failed', 'error', 'exception', 'not vulnerable',
            'access denied', 'connection refused', 'timeout',
            'traceback', 'syntax error', 'permission denied',
            'target is probably patched', 'attack failed', 'modulenotfounderror'
        ]
        
        if any(indicator in output_lower for indicator in failure_indicators):
            return False
        
        # Check return code and output length
        if return_code == 0 and len(output.strip()) > 20:
            # Look for positive indicators in the output
            positive_keywords = ['success', 'ok', 'done', 'complete', 'found', 'detected']
            if any(keyword in output_lower for keyword in positive_keywords):
                return True
        
        return False
    
    def _extract_artifacts_enhanced(self, output: str, cve_id: str) -> List[str]:
        """Extract security artifacts from exploit output"""
        artifacts = []
        import re
        
        # General patterns
        patterns = [
            (r'password[:\s]+([^\s\n]+)', 'Password'),
            (r'username[:\s]+([^\s\n]+)', 'Username'),
            (r'hash[:\s]+([a-f0-9]{32,})', 'Hash'),
            (r'token[:\s]+([^\s\n]+)', 'Token'),
            (r'session[:\s]+([^\s\n]+)', 'Session ID'),
            (r'credential[s]?[:\s]+([^\n]+)', 'Credentials'),
            (r'secret[:\s]+([^\s\n]+)', 'Secret'),
            (r'key[:\s]+([^\s\n]+)', 'Key'),
            (r'admin[:\s]+([^\s\n]+)', 'Admin Access'),
            (r'shell[:\s]+([^\s\n]+)', 'Shell Access'),
        ]
        
        # Apply general patterns
        for pattern, artifact_type in patterns:
            matches = re.finditer(pattern, output, re.IGNORECASE)
            for match in matches:
                artifacts.append(f"{artifact_type}: {match.group(1)}")
        
        # Look for file paths or URLs
        file_patterns = [
            r'/[^\s]+\.(?:txt|log|conf|cfg|ini|xml|json)',
            r'[a-zA-Z]:\\[^\s]+\.(?:txt|log|conf|cfg|ini|xml|json)',
            r'https?://[^\s]+',
        ]
        
        for pattern in file_patterns:
            matches = re.finditer(pattern, output)
            for match in matches:
                artifacts.append(f"File/URL: {match.group()}")
        
        return list(set(artifacts))[:10]  # Remove duplicates and limit
    
    def _identify_success_indicators_enhanced(self, output: str, cve_id: str) -> List[str]:
        """Identify success indicators from exploit output"""
        indicators = []
        output_lower = output.lower()
        
        # General success patterns
        general_patterns = [
            'exploit successful', 'shell obtained', 'access granted', 'login successful',
            'authentication bypassed', 'privilege escalation', 'vulnerability confirmed',
            'target vulnerable', 'exploit complete', 'payload executed', 'backdoor installed'
        ]
        
        # Check general patterns
        for pattern in general_patterns:
            if pattern in output_lower:
                indicators.append(pattern.title())
        
        return list(set(indicators))[:5]  # Remove duplicates and limit
    
    def _get_secure_env(self) -> Dict[str, str]:
        """Get secure environment variables for execution"""
        return {
            'PATH': '/usr/local/bin:/usr/bin:/bin',
            'HOME': '/tmp',
            'LANG': 'C.UTF-8',
            'LC_ALL': 'C.UTF-8',
            'PYTHONPATH': '',
            'PYTHONHOME': '',
        }
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result to file"""
        try:
            filename = f"{target_ip}_exploit_{cve_id}_{poc_index}.json"
            filepath = config.DATA_DIR / filename
            
            with open(filepath, 'w') as f:
                json.dump(result.dict(), f, indent=2, default=str)
        except Exception as e:
            logger.warning(f"Failed to save exploit result: {e}")
    
    def cleanup(self):
        """Clean up resources"""
        if hasattr(self, 'git_executor'):
            self.git_executor.cleanup()
    
    def __del__(self):
        """Ensure cleanup on destruction"""
        try:
            self.cleanup()
        except:
            pass
