import json
import os
import time
import re
from typing import List, Dict, Any
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
from backend.utils.file_handler import FileHandler
from backend.utils.sandbox import SandboxExecutor
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.exploits_dir = config.DATA_DIR / "exploits"
        self.exploits_dir.mkdir(exist_ok=True)
        self.file_handler = FileHandler()
        self.sandbox = SandboxExecutor()
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs and auto-retry functionality"""
        logger.info(f"Starting exploit execution for {cve_id} on {target_ip} ({len(poc_result.available_pocs)} PoCs)")
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                break
            
            logger.info(f"Attempting PoC #{i}: {poc.source}")
            result = self._execute_single_poc_enhanced(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                logger.info(f"✓ SUCCESS: PoC #{i} succeeded!")
                success_achieved = True
            else:
                logger.warning(f"✗ FAILED: PoC #{i}")
                if i < len(poc_result.available_pocs):
                    time.sleep(2)
        
        logger.info(f"Exploit execution complete: {'SUCCESS' if success_achieved else 'ALL FAILED'}")
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with enhanced retry logic"""
        all_results = []
        for poc_result in approved_pocs:
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
        return all_results
    
    def _execute_single_poc_enhanced(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute a single PoC with enhanced error handling and analysis"""
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url
        )
        
        start_time = time.time()
        
        try:
            # Method 1: Use saved PoC file if available
            if hasattr(poc, 'filename') and poc.filename:
                execution_result = self._execute_saved_poc_file(poc.filename, target_ip)
                result.exploit_used = f"Saved PoC: {poc.filename}"
            
            # Method 2: Execute code directly
            elif poc.code and poc.code.strip():
                execution_result = self._execute_poc_code_enhanced(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct execution: {poc.source}"
            
            # Method 3: Try to fetch and execute from URL
            else:
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Process execution results
            result.execution_output = execution_result.get('output', '')
            result.success = execution_result.get('success', False)
            result.execution_time = round(time.time() - start_time, 2)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            result.return_code = execution_result.get('return_code', -1)
            
            # Enhanced success analysis
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output)
                result.success_indicators = self._identify_success_indicators(result.execution_output)
                if result.artifacts_captured:
                    logger.info(f"  Artifacts found: {result.artifacts_captured}")
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            logger.error(f"PoC #{poc_index} execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        return result
    
    def _execute_saved_poc_file(self, filename: str, target_ip: str) -> Dict[str, Any]:
        """Execute a saved PoC file with enhanced security and encoding fixes"""
        try:
            filepath = self.exploits_dir / filename
            if not filepath.exists():
                return {'success': False, 'output': f'PoC file not found: {filename}', 'error': 'File not found'}
            
            # Clean file content from BOM issues
            if not self.file_handler.clean_file_encoding(filepath):
                return {'success': False, 'output': f'Error cleaning file: {filename}', 'error': 'Encoding error'}
            
            # Determine execution method based on extension
            extension = filename.split('.')[-1].lower()
            return self.sandbox.execute_file(filepath, target_ip, extension)
        
        except Exception as e:
            return {'success': False, 'output': f'Error executing saved PoC: {str(e)}', 'error': str(e)}
    
    def _execute_poc_code_enhanced(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Execute PoC code with enhanced processing and security"""
        try:
            # Clean and prepare code
            cleaned_code = self.file_handler.clean_content(code)
            extension = self.file_handler.detect_file_extension(cleaned_code)
            
            # Create filename
            cve_clean = cve_id.replace('CVE-', '').replace('cve-', '')
            filename = f"cve-{cve_clean}-{poc_index:03d}.{extension}"
            filepath = self.exploits_dir / filename
            
            # Process and wrap code
            processed_code = self.file_handler.inject_target_ip(cleaned_code, target_ip)
            safe_code = self.file_handler.wrap_code_safely(processed_code, cve_id, target_ip, extension)
            
            # Save and execute
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(safe_code)
            os.chmod(filepath, 0o755)
            
            return self.sandbox.execute_file(filepath, target_ip, extension)
                
        except Exception as e:
            return {'success': False, 'output': f'Code execution error: {str(e)}', 'error': str(e), 'return_code': -1}
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute with enhanced security"""
        try:
            import requests
            response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'}, timeout=15)
            
            if response.status_code == 200:
                code = self.file_handler.clean_content(response.text)
                if self.file_handler.is_executable_code(code):
                    return self._execute_poc_code_enhanced(code, target_ip, cve_id, poc_index)
                else:
                    return {'success': False, 'output': f'URL content not executable: {url}', 'error': 'Not executable', 'return_code': -1}
            else:
                return {'success': False, 'output': f'Failed to fetch: {url} ({response.status_code})', 'error': f'HTTP {response.status_code}', 'return_code': -1}
        except Exception as e:
            return {'success': False, 'output': f'URL fetch error: {str(e)}', 'error': str(e), 'return_code': -1}
    
    def _extract_artifacts_enhanced(self, output: str) -> List[str]:
        """Extract security artifacts from exploit output"""
        artifacts = []
        patterns = [
            r'password[:\s]+([^\s\n]+)',
            r'username[:\s]+([^\s\n]+)',
            r'hash[:\s]+([a-f0-9]{32,})',
            r'token[:\s]+([^\s\n]+)',
            r'session[:\s]+([^\s\n]+)',
            r'cookie[:\s]+([^\s\n]+)',
            r'credential[s]?[:\s]+([^\n]+)',
            r'secret[:\s]+([^\s\n]+)',
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, output, re.IGNORECASE)
            for match in matches:
                artifacts.append(f"{pattern.split('[')[0]}: {match.group(1)}")
        
        return list(set(artifacts))[:10]  # Limit to 10 unique artifacts
    
    def _identify_success_indicators(self, output: str) -> List[str]:
        """Identify success indicators from exploit output"""
        indicators = []
        success_patterns = [
            'exploit successful', 'shell obtained', 'access granted', 'login successful',
            'authentication bypassed', 'privilege escalation', 'root access', 'admin access',
            'payload executed', 'code execution', 'vulnerability confirmed', 'target vulnerable'
        ]
        
        output_lower = output.lower()
        for pattern in success_patterns:
            if pattern in output_lower:
                indicators.append(pattern.title())
        
        return indicators[:5]  # Limit to 5 indicators
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result to file"""
        try:
            filename = f"{target_ip}_exploit_{cve_id}_{poc_index}.json"
            filepath = config.DATA_DIR / filename
            
            with open(filepath, 'w') as f:
                json.dump(result.dict(), f, indent=2, default=str)
        except Exception as e:
            logger.warning(f"Failed to save exploit result: {e}")
