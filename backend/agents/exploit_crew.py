import json
import os
import time
from typing import List, Dict, Any
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
from backend.utils.git_poc_executor import GitPoCExecutor
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.git_executor = GitPoCExecutor()
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs using git clone approach"""
        logger.info(f"Starting git-based exploit execution for {cve_id} on {target_ip} ({len(poc_result.available_pocs)} PoCs)")
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                logger.info("Success already achieved, skipping remaining PoCs")
                break
            
            logger.info(f"Attempting PoC #{i}: {poc.source} - {poc.url}")
            result = self._execute_single_poc_git(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                logger.info(f"✓ SUCCESS: PoC #{i} succeeded using git clone!")
                success_achieved = True
            else:
                logger.warning(f"✗ FAILED: PoC #{i} - {result.failure_reason}")
                if i < len(poc_result.available_pocs):
                    time.sleep(2)
        
        logger.info(f"Git-based exploit execution complete: {'SUCCESS' if success_achieved else 'ALL FAILED'}")
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with git clone retry logic"""
        all_results = []
        for poc_result in approved_pocs:
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
        return all_results
    
    def _execute_single_poc_git(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute a single PoC using git clone approach"""
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url
        )
        
        start_time = time.time()
        
        try:
            # Check if it's a GitHub URL that can be cloned
            if self._is_github_url(poc.url):
                logger.info(f"Executing GitHub PoC via git clone: {poc.url}")
                execution_result = self.git_executor.execute_github_poc(poc.url, target_ip, cve_id)
                result.exploit_used = f"Git clone: {poc.url}"
            
            # Fallback to direct code execution if available
            elif poc.code and poc.code.strip():
                logger.info(f"Executing PoC code directly (fallback)")
                execution_result = self._execute_poc_code_fallback(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct code execution: {poc.source}"
            
            # Try to fetch and execute from URL as last resort
            else:
                logger.info(f"Attempting to fetch and execute from URL: {poc.url}")
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Process execution results
            result.execution_output = execution_result.get('output', '')
            result.success = execution_result.get('success', False)
            result.execution_time = round(time.time() - start_time, 2)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            result.return_code = execution_result.get('return_code', -1)
            
            # Enhanced success analysis
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output)
                result.success_indicators = self._identify_success_indicators(result.execution_output)
                if result.artifacts_captured:
                    logger.info(f"  Artifacts found: {result.artifacts_captured}")
                
                # Log additional details for successful git clone
                if 'executed_file' in execution_result:
                    logger.info(f"  Executed file: {execution_result['executed_file']}")
                if 'command' in execution_result:
                    logger.info(f"  Command used: {execution_result['command']}")
                    
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
                
                # Log additional failure details for git clone
                if 'files_tried' in execution_result:
                    logger.debug(f"  Files attempted: {execution_result['files_tried']}")
                if 'all_attempts' in execution_result:
                    logger.debug(f"  Total attempts: {len(execution_result['all_attempts'])}")
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            logger.error(f"PoC #{poc_index} execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        return result
    
    def _is_github_url(self, url: str) -> bool:
        """Check if URL is a GitHub repository URL"""
        if not url:
            return False
        
        github_patterns = [
            'github.com',
            'raw.githubusercontent.com'
        ]
        
        url_lower = url.lower()
        is_github = any(pattern in url_lower for pattern in github_patterns)
        
        # Exclude direct file URLs as they should be handled differently
        is_direct_file = any(ext in url_lower for ext in ['.py', '.sh', '.rb', '.pl', '.c', '.cpp'])
        
        return is_github and not is_direct_file
    
    def _execute_poc_code_fallback(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fallback method for executing PoC code directly"""
        try:
            import tempfile
            
            # Create temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp_file:
                # Simple wrapper for the code
                wrapped_code = f"""#!/usr/bin/env python3
import sys
target_ip = "{target_ip}" if len(sys.argv) <= 1 else sys.argv[1]

{code}
"""
                tmp_file.write(wrapped_code)
                tmp_file.flush()
                
                # Make executable
                os.chmod(tmp_file.name, 0o755)
                
                # Execute
                import subprocess
                result = subprocess.run(
                    ['python3', tmp_file.name, target_ip],
                    capture_output=True,
                    text=True,
                    timeout=120
                )
                
                # Clean up
                try:
                    os.unlink(tmp_file.name)
                except:
                    pass
                
                output = result.stdout + result.stderr
                success = self._analyze_execution_success(output, result.returncode)
                
                return {
                    'success': success,
                    'output': output,
                    'error': result.stderr if not success else None,
                    'return_code': result.returncode
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'Fallback execution error: {str(e)}',
                'error': str(e),
                'return_code': -1
            }
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute"""
        try:
            import requests
            import tempfile
            
            headers = {'User-Agent': 'Mozilla/5.0 (compatible; BreachPilot)'}
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                content = response.text
                
                # Determine file type and create temporary file
                if any(ext in url.lower() for ext in ['.py']):
                    suffix = '.py'
                    interpreter = ['python3']
                elif any(ext in url.lower() for ext in ['.sh']):
                    suffix = '.sh'
                    interpreter = ['bash']
                elif any(ext in url.lower() for ext in ['.rb']):
                    suffix = '.rb'
                    interpreter = ['ruby']
                elif any(ext in url.lower() for ext in ['.pl']):
                    suffix = '.pl'
                    interpreter = ['perl']
                else:
                    # Default to python
                    suffix = '.py'
                    interpreter = ['python3']
                
                # Create and execute temporary file
                with tempfile.NamedTemporaryFile(mode='w', suffix=suffix, delete=False) as tmp_file:
                    tmp_file.write(content)
                    tmp_file.flush()
                    
                    os.chmod(tmp_file.name, 0o755)
                    
                    import subprocess
                    result = subprocess.run(
                        interpreter + [tmp_file.name, target_ip],
                        capture_output=True,
                        text=True,
                        timeout=120
                    )
                    
                    # Clean up
                    try:
                        os.unlink(tmp_file.name)
                    except:
                        pass
                    
                    output = result.stdout + result.stderr
                    success = self._analyze_execution_success(output, result.returncode)
                    
                    return {
                        'success': success,
                        'output': output,
                        'error': result.stderr if not success else None,
                        'return_code': result.returncode
                    }
            else:
                return {
                    'success': False,
                    'output': f'Failed to fetch from URL: {url} (HTTP {response.status_code})',
                    'error': f'HTTP {response.status_code}',
                    'return_code': -1
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'URL fetch error: {str(e)}',
                'error': str(e),
                'return_code': -1
            }
    
    def _analyze_execution_success(self, output: str, return_code: int) -> bool:
        """Analyze if execution was successful"""
        output_lower = output.lower()
        
        # Strong success indicators
        success_indicators = [
            'exploit successful', 'successfully exploited', 'shell obtained',
            'access granted', 'vulnerability confirmed', 'target vulnerable',
            'privilege escalation', 'authentication bypassed', 'payload executed'
        ]
        
        # Failure indicators
        failure_indicators = [
            'failed', 'error', 'exception', 'not vulnerable',
            'access denied', 'connection refused', 'timeout',
            'traceback', 'syntax error'
        ]
        
        # Check for explicit success messages
        if any(indicator in output_lower for indicator in success_indicators):
            return True
        
        # Check for explicit failure messages
        if any(indicator in output_lower for indicator in failure_indicators):
            return False
        
        # If return code is 0 and there's substantial output, consider success
        if return_code == 0 and len(output.strip()) > 20:
            return True
        
        return False
    
    def _extract_artifacts_enhanced(self, output: str) -> List[str]:
        """Extract security artifacts from exploit output"""
        artifacts = []
        import re
        
        patterns = [
            r'password[:\s]+([^\s\n]+)',
            r'username[:\s]+([^\s\n]+)',
            r'hash[:\s]+([a-f0-9]{32,})',
            r'token[:\s]+([^\s\n]+)',
            r'session[:\s]+([^\s\n]+)',
            r'cookie[:\s]+([^\s\n]+)',
            r'credential[s]?[:\s]+([^\n]+)',
            r'secret[:\s]+([^\s\n]+)',
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, output, re.IGNORECASE)
            for match in matches:
                artifacts.append(f"{pattern.split('[')[0]}: {match.group(1)}")
        
        return list(set(artifacts))[:10]  # Limit to 10 unique artifacts
    
    def _identify_success_indicators(self, output: str) -> List[str]:
        """Identify success indicators from exploit output"""
        indicators = []
        success_patterns = [
            'exploit successful', 'shell obtained', 'access granted', 'login successful',
            'authentication bypassed', 'privilege escalation', 'root access', 'admin access',
            'payload executed', 'code execution', 'vulnerability confirmed', 'target vulnerable'
        ]
        
        output_lower = output.lower()
        for pattern in success_patterns:
            if pattern in output_lower:
                indicators.append(pattern.title())
        
        return indicators[:5]  # Limit to 5 indicators
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result to file"""
        try:
            filename = f"{target_ip}_exploit_{cve_id}_{poc_index}.json"
            filepath = config.DATA_DIR / filename
            
            with open(filepath, 'w') as f:
                json.dump(result.dict(), f, indent=2, default=str)
        except Exception as e:
            logger.warning(f"Failed to save exploit result: {e}")
    
    def cleanup(self):
        """Clean up resources"""
        if hasattr(self, 'git_executor'):
            self.git_executor.cleanup()
    
    def __del__(self):
        """Ensure cleanup on destruction"""
        try:
            self.cleanup()
        except:
            pass
