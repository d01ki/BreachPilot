import json
import os
import time
import subprocess
import tempfile
from typing import List, Dict, Any
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
from backend.utils.git_poc_executor import GitPoCExecutor
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.git_executor = GitPoCExecutor()
        logger.info("ExploitCrew initialized with enhanced git clone executor")
    
    def execute_single_poc_enhanced(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute single PoC with enhanced success detection"""
        logger.info(f"ðŸš€ Executing PoC #{poc_index} for {cve_id}: {poc.source} - {poc.url}")
        
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url,
            timestamp=time.time()
        )
        
        start_time = time.time()
        
        try:
            # Choose execution method based on PoC type
            if self._is_github_url(poc.url):
                logger.info(f"Executing GitHub PoC via git clone: {poc.url}")
                execution_result = self.git_executor.execute_github_poc(poc.url, target_ip, cve_id)
                result.exploit_used = f"Git clone: {poc.url}"
                
            elif poc.code and poc.code.strip():
                logger.info(f"Executing PoC code directly")
                execution_result = self._execute_poc_code_enhanced(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct code execution: {poc.source}"
                
            else:
                logger.info(f"Attempting to fetch and execute from URL: {poc.url}")
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Enhanced result processing
            result.execution_output = execution_result.get('output', '')
            result.command = execution_result.get('command', '')
            result.execution_time = round(time.time() - start_time, 2)
            result.return_code = execution_result.get('return_code', -1)
            
            # Enhanced success analysis
            result.success = self._analyze_execution_success_enhanced(result.execution_output, result.return_code, cve_id)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output, cve_id)
                result.success_indicators = self._identify_success_indicators_enhanced(result.execution_output, cve_id)
                result.vulnerability_confirmed = True
                result.exploit_successful = True
                
                logger.info(f"âœ… SUCCESS: PoC #{poc_index} executed successfully!")
                if result.artifacts_captured:
                    logger.info(f"  ðŸŽ¯ Artifacts captured: {result.artifacts_captured}")
                if result.success_indicators:
                    logger.info(f"  âœ“ Success indicators: {result.success_indicators}")
                    
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
                result.vulnerability_confirmed = False
                result.exploit_successful = False
                logger.warning(f"âŒ FAILED: PoC #{poc_index} - {result.failure_reason}")
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            result.success = False
            logger.error(f"PoC #{poc_index} execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        return result
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs using enhanced approach"""
        logger.info(f"Starting enhanced exploit execution for {cve_id} on {target_ip} ({len(poc_result.available_pocs)} PoCs)")
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                logger.info("Success already achieved, skipping remaining PoCs")
                break
            
            result = self.execute_single_poc_enhanced(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                success_achieved = True
            else:
                if i < len(poc_result.available_pocs):
                    time.sleep(2)
        
        logger.info(f"Enhanced exploit execution complete: {'SUCCESS' if success_achieved else 'ALL FAILED'}")
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with enhanced retry logic"""
        all_results = []
        for poc_result in approved_pocs:
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
        return all_results
    
    def _is_github_url(self, url: str) -> bool:
        """Check if URL is a GitHub repository URL"""
        if not url:
            return False
        
        github_patterns = ['github.com', 'raw.githubusercontent.com']
        url_lower = url.lower()
        is_github = any(pattern in url_lower for pattern in github_patterns)
        
        # Exclude direct file URLs as they should be handled differently
        is_direct_file = any(ext in url_lower for ext in ['.py', '.sh', '.rb', '.pl', '.c', '.cpp'])
        
        return is_github and not is_direct_file
    
    def _execute_poc_code_enhanced(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Enhanced method for executing PoC code directly"""
        try:
            # Determine script type
            if code.startswith('#!/usr/bin/env python') or 'import ' in code[:300]:
                interpreter = 'python3'
                suffix = '.py'
            elif code.startswith('#!/bin/bash') or code.startswith('#!/bin/sh'):
                interpreter = 'bash'
                suffix = '.sh'
            elif code.startswith('#!/usr/bin/ruby') or 'require ' in code[:200]:
                interpreter = 'ruby'
                suffix = '.rb'
            elif '#include' in code[:200]:
                interpreter = 'gcc'
                suffix = '.c'
            else:
                interpreter = 'python3'
                suffix = '.py'
            
            # Create temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix=suffix, delete=False) as tmp_file:
                if interpreter == 'python3' and not code.startswith('#!'):
                    # Add target IP handling for Python scripts
                    wrapped_code = f"""#!/usr/bin/env python3
import sys
import os

# Handle target IP argument
target_ip = "{target_ip}"
if len(sys.argv) > 1:
    target_ip = sys.argv[1]

# CVE ID for reference
cve_id = "{cve_id}"

# Original PoC code below:
{code}
"""
                    tmp_file.write(wrapped_code)
                else:
                    tmp_file.write(code)
                
                tmp_file.flush()
                os.chmod(tmp_file.name, 0o755)
                
                # Execute based on interpreter
                if interpreter == 'gcc':
                    # Compile C code first
                    executable = tmp_file.name.replace('.c', '')
                    compile_result = subprocess.run(
                        ['gcc', '-o', executable, tmp_file.name],
                        capture_output=True,
                        text=True,
                        timeout=30
                    )
                    
                    if compile_result.returncode == 0:
                        cmd = [executable, target_ip]
                    else:
                        return {
                            'success': False,
                            'output': f'Compilation failed: {compile_result.stderr}',
                            'error': 'Compilation error',
                            'return_code': compile_result.returncode,
                            'command': f'gcc -o {executable} {tmp_file.name}'
                        }
                else:
                    cmd = [interpreter, tmp_file.name, target_ip]
                
                # Execute the script
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=180,  # 3 minute timeout
                    env=self._get_secure_env()
                )
                
                # Cleanup
                try:
                    os.unlink(tmp_file.name)
                    if interpreter == 'gcc' and 'executable' in locals():
                        os.unlink(executable)
                except:
                    pass
                
                output = result.stdout + result.stderr
                success = self._analyze_execution_success_enhanced(output, result.returncode, cve_id)
                
                return {
                    'success': success,
                    'output': output,
                    'error': result.stderr if not success else None,
                    'return_code': result.returncode,
                    'command': ' '.join(cmd)
                }
                
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': 'Execution timeout exceeded (180 seconds)',
                'error': 'Timeout',
                'return_code': -1,
                'command': ' '.join(cmd) if 'cmd' in locals() else 'Unknown'
            }
        except Exception as e:
            return {
                'success': False,
                'output': f'Enhanced execution error: {str(e)}',
                'error': str(e),
                'return_code': -1,
                'command': 'Error during setup'
            }
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute with enhancements"""
        try:
            import requests
            
            headers = {'User-Agent': 'Mozilla/5.0 (compatible; BreachPilot)'}
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                content = response.text
                
                # Determine file type and execute
                return self._execute_poc_code_enhanced(content, target_ip, cve_id, poc_index)
            else:
                return {
                    'success': False,
                    'output': f'Failed to fetch from URL: {url} (HTTP {response.status_code})',
                    'error': f'HTTP {response.status_code}',
                    'return_code': -1,
                    'command': f'curl {url}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'URL fetch error: {str(e)}',
                'error': str(e),
                'return_code': -1,
                'command': f'curl {url}'
            }
    
    def _analyze_execution_success_enhanced(self, output: str, return_code: int, cve_id: str) -> bool:
        """Enhanced analysis to determine if execution was successful"""
        output_lower = output.lower()
        
        # General success indicators
        general_success_indicators = [
            'exploit successful', 'successfully exploited', 'shell obtained',
            'access granted', 'vulnerability confirmed', 'target vulnerable',
            'privilege escalation', 'authentication bypassed', 'payload executed',
            'exploit complete', 'pwned', 'compromised', 'backdoor installed',
            'reverse shell', 'meterpreter session', 'command executed'
        ]
        
        # Check general indicators
        if any(indicator in output_lower for indicator in general_success_indicators):
            return True
        
        # Check for failure indicators
        failure_indicators = [
            'failed', 'error', 'exception', 'not vulnerable',
            'access denied', 'connection refused', 'timeout',
            'traceback', 'syntax error', 'permission denied',
            'target is probably patched', 'attack failed'
        ]
        
        if any(indicator in output_lower for indicator in failure_indicators):
            return False
        
        # Check return code and output length
        if return_code == 0 and len(output.strip()) > 20:
            # Look for positive indicators in the output
            positive_keywords = ['success', 'ok', 'done', 'complete', 'found', 'detected']
            if any(keyword in output_lower for keyword in positive_keywords):
                return True
        
        return False
    
    def _extract_artifacts_enhanced(self, output: str, cve_id: str) -> List[str]:
        """Extract security artifacts from exploit output"""
        artifacts = []
        import re
        
        # General patterns
        patterns = [
            (r'password[:\s]+([^\s\n]+)', 'Password'),
            (r'username[:\s]+([^\s\n]+)', 'Username'),
            (r'hash[:\s]+([a-f0-9]{32,})', 'Hash'),
            (r'token[:\s]+([^\s\n]+)', 'Token'),
            (r'session[:\s]+([^\s\n]+)', 'Session ID'),
            (r'credential[s]?[:\s]+([^\n]+)', 'Credentials'),
            (r'secret[:\s]+([^\s\n]+)', 'Secret'),
            (r'key[:\s]+([^\s\n]+)', 'Key'),
            (r'admin[:\s]+([^\s\n]+)', 'Admin Access'),
            (r'shell[:\s]+([^\s\n]+)', 'Shell Access'),
        ]
        
        # Apply general patterns
        for pattern, artifact_type in patterns:
            matches = re.finditer(pattern, output, re.IGNORECASE)
            for match in matches:
                artifacts.append(f"{artifact_type}: {match.group(1)}")
        
        # Look for file paths or URLs
        file_patterns = [
            r'/[^\s]+\.(?:txt|log|conf|cfg|ini|xml|json)',
            r'[a-zA-Z]:\\[^\s]+\.(?:txt|log|conf|cfg|ini|xml|json)',
            r'https?://[^\s]+',
        ]
        
        for pattern in file_patterns:
            matches = re.finditer(pattern, output)
            for match in matches:
                artifacts.append(f"File/URL: {match.group()}")
        
        return list(set(artifacts))[:10]  # Remove duplicates and limit
    
    def _identify_success_indicators_enhanced(self, output: str, cve_id: str) -> List[str]:
        """Identify success indicators from exploit output"""
        indicators = []
        output_lower = output.lower()
        
        # General success patterns
        general_patterns = [
            'exploit successful', 'shell obtained', 'access granted', 'login successful',
            'authentication bypassed', 'privilege escalation', 'vulnerability confirmed',
            'target vulnerable', 'exploit complete', 'payload executed', 'backdoor installed'
        ]
        
        # Check general patterns
        for pattern in general_patterns:
            if pattern in output_lower:
                indicators.append(pattern.title())
        
        return list(set(indicators))[:5]  # Remove duplicates and limit
    
    def _get_secure_env(self) -> Dict[str, str]:
        """Get secure environment variables for execution"""
        return {
            'PATH': '/usr/local/bin:/usr/bin:/bin',
            'HOME': '/tmp',
            'LANG': 'C.UTF-8',
            'LC_ALL': 'C.UTF-8',
            'PYTHONPATH': '',
            'PYTHONHOME': '',
        }
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result to file"""
        try:
            filename = f"{target_ip}_exploit_{cve_id}_{poc_index}.json"
            filepath = config.DATA_DIR / filename
            
            with open(filepath, 'w') as f:
                json.dump(result.dict(), f, indent=2, default=str)
        except Exception as e:
            logger.warning(f"Failed to save exploit result: {e}")
    
    def cleanup(self):
        """Clean up resources"""
        if hasattr(self, 'git_executor'):
            self.git_executor.cleanup()
    
    def __del__(self):
        """Ensure cleanup on destruction"""
        try:
            self.cleanup()
        except:
            pass
