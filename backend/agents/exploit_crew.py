import json
import os
import time
import subprocess
import tempfile
import re
import sys
from typing import List, Dict, Any
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
from backend.utils.git_poc_executor import GitPoCExecutor
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.git_executor = GitPoCExecutor()
        logger.info("ExploitCrew initialized with enhanced git clone executor")
    
    def execute_single_poc_enhanced(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute single PoC with enhanced success detection and autonomous dependency handling"""
        logger.info(f"üöÄ Executing PoC #{poc_index} for {cve_id}: {poc.source} - {poc.url}")
        
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url,
            timestamp=time.time()
        )
        
        start_time = time.time()
        
        try:
            # Choose execution method based on PoC type
            if self._is_github_url(poc.url):
                logger.info(f"Executing GitHub PoC via git clone: {poc.url}")
                execution_result = self.git_executor.execute_github_poc(poc.url, target_ip, cve_id)
                result.exploit_used = f"Git clone: {poc.url}"
                
            elif poc.code and poc.code.strip():
                logger.info(f"Executing PoC code directly")
                execution_result = self._execute_poc_code_enhanced(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct code execution: {poc.source}"
                
            else:
                logger.info(f"Attempting to fetch and execute from URL: {poc.url}")
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Enhanced result processing
            result.execution_output = execution_result.get('output', '')
            result.execution_command = execution_result.get('command', '')
            result.execution_time = round(time.time() - start_time, 2)
            result.return_code = execution_result.get('return_code', -1)
            
            # Enhanced success analysis
            result.success = self._analyze_execution_success_enhanced(result.execution_output, result.return_code, cve_id)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output, cve_id)
                result.success_indicators = self._identify_success_indicators_enhanced(result.execution_output, cve_id)
                result.vulnerability_confirmed = True
                result.exploit_successful = True
                
                logger.info(f"‚úÖ SUCCESS: PoC #{poc_index} executed successfully!")
                if result.artifacts_captured:
                    logger.info(f"  üéØ Artifacts captured: {result.artifacts_captured}")
                if result.success_indicators:
                    logger.info(f"  ‚úì Success indicators: {result.success_indicators}")
                    
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
                result.vulnerability_confirmed = False
                result.exploit_successful = False
                logger.warning(f"‚ùå FAILED: PoC #{poc_index} - {result.failure_reason}")
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            result.success = False
            logger.error(f"PoC #{poc_index} execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        return result
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs using enhanced approach"""
        logger.info(f"Starting enhanced exploit execution for {cve_id} on {target_ip} ({len(poc_result.available_pocs)} PoCs)")
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                logger.info("Success already achieved, skipping remaining PoCs")
                break
            
            result = self.execute_single_poc_enhanced(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                success_achieved = True
            else:
                if i < len(poc_result.available_pocs):
                    time.sleep(2)
        
        logger.info(f"Enhanced exploit execution complete: {'SUCCESS' if success_achieved else 'ALL FAILED'}")
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with enhanced retry logic"""
        all_results = []
        for poc_result in approved_pocs:
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
        return all_results
    
    def _is_github_url(self, url: str) -> bool:
        """Check if URL is a GitHub repository URL"""
        if not url:
            return False
        
        github_patterns = ['github.com', 'raw.githubusercontent.com']
        url_lower = url.lower()
        is_github = any(pattern in url_lower for pattern in github_patterns)
        
        # Exclude direct file URLs as they should be handled differently
        is_direct_file = any(ext in url_lower for ext in ['.py', '.sh', '.rb', '.pl', '.c', '.cpp'])
        
        return is_github and not is_direct_file
    
    def _analyze_dependencies(self, code: str) -> List[str]:
        """Analyze code to detect required dependencies"""
        dependencies = []
        
        # Python imports
        python_imports = re.findall(r'import\s+([a-zA-Z_][a-zA-Z0-9_]*)', code)
        python_from_imports = re.findall(r'from\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+import', code)
        
        all_imports = python_imports + python_from_imports
        
        # Common third-party packages that often need installation
        common_packages = {
            'pyfiglet': 'pyfiglet',
            'requests': 'requests',
            'paramiko': 'paramiko',
            'impacket': 'impacket',
            'ldap3': 'ldap3',
            'pycrypto': 'pycrypto',
            'cryptography': 'cryptography',
            'scapy': 'scapy',
            'numpy': 'numpy',
            'colorama': 'colorama',
            'termcolor': 'termcolor',
            'socket': None,  # Built-in
            'sys': None,     # Built-in
            'os': None,      # Built-in
            'time': None,    # Built-in
            'datetime': None,# Built-in
            'json': None,    # Built-in
            'base64': None,  # Built-in
            'hashlib': None, # Built-in
            'struct': None,  # Built-in
            'binascii': None,# Built-in
            'socket': None,  # Built-in
            'subprocess': None, # Built-in
            'threading': None,  # Built-in
            'ssl': None,     # Built-in
        }
        
        for import_name in all_imports:
            if import_name in common_packages and common_packages[import_name] is not None:
                dependencies.append(common_packages[import_name])
        
        return list(set(dependencies))
    
    def _get_python_executable(self) -> str:
        """Get the current Python executable path"""
        return sys.executable
    
    def _install_dependencies_robust(self, dependencies: List[str]) -> Dict[str, bool]:
        """Robustly install required dependencies with multiple retry strategies"""
        installation_results = {}
        python_exe = self._get_python_executable()
        
        for dep in dependencies:
            logger.info(f"üîß Auto-installing dependency: {dep}")
            success = False
            
            # Strategy 1: Use current Python executable with pip module
            try:
                result = subprocess.run(
                    [python_exe, '-m', 'pip', 'install', dep],
                    capture_output=True,
                    text=True,
                    timeout=90
                )
                
                if result.returncode == 0:
                    success = True
                    logger.info(f"‚úÖ Successfully installed {dep} (method 1)")
                else:
                    logger.warning(f"‚ö†Ô∏è Method 1 failed for {dep}: {result.stderr}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Method 1 exception for {dep}: {e}")
            
            # Strategy 2: Try pip3 directly
            if not success:
                try:
                    result = subprocess.run(
                        ['pip3', 'install', dep],
                        capture_output=True,
                        text=True,
                        timeout=90
                    )
                    
                    if result.returncode == 0:
                        success = True
                        logger.info(f"‚úÖ Successfully installed {dep} (method 2)")
                    else:
                        logger.warning(f"‚ö†Ô∏è Method 2 failed for {dep}: {result.stderr}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Method 2 exception for {dep}: {e}")
            
            # Strategy 3: Try with --user flag
            if not success:
                try:
                    result = subprocess.run(
                        [python_exe, '-m', 'pip', 'install', '--user', dep],
                        capture_output=True,
                        text=True,
                        timeout=90
                    )
                    
                    if result.returncode == 0:
                        success = True
                        logger.info(f"‚úÖ Successfully installed {dep} (method 3 - user)")
                    else:
                        logger.warning(f"‚ö†Ô∏è Method 3 failed for {dep}: {result.stderr}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Method 3 exception for {dep}: {e}")
            
            installation_results[dep] = success
            if not success:
                logger.error(f"‚ùå All installation methods failed for {dep}")
        
        return installation_results
    
    def _test_import(self, module_name: str) -> bool:
        """Test if a module can be imported successfully"""
        try:
            result = subprocess.run(
                [self._get_python_executable(), '-c', f'import {module_name}; print("OK")'],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode == 0 and 'OK' in result.stdout
        except Exception:
            return False
    
    def _execute_poc_code_enhanced(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Enhanced method with autonomous dependency management and self-healing"""
        max_retries = 3
        
        for attempt in range(max_retries):
            logger.info(f"üéØ Execution attempt {attempt + 1}/{max_retries}")
            
            try:
                # Analyze dependencies
                dependencies = self._analyze_dependencies(code)
                installation_log = []
                
                if dependencies:
                    logger.info(f"üîç Detected dependencies: {dependencies}")
                    installation_log.append(f"Detected dependencies: {', '.join(dependencies)}")
                    
                    # Test current state
                    missing_deps = []
                    for dep in dependencies:
                        if not self._test_import(dep):
                            missing_deps.append(dep)
                    
                    if missing_deps:
                        logger.info(f"üîß Missing dependencies: {missing_deps}")
                        installation_log.append(f"Missing: {', '.join(missing_deps)}")
                        
                        # Install missing dependencies
                        install_results = self._install_dependencies_robust(missing_deps)
                        
                        # Verify installation
                        still_missing = []
                        for dep in missing_deps:
                            if install_results.get(dep, False):
                                if self._test_import(dep):
                                    installation_log.append(f"‚úÖ {dep} installed and verified")
                                else:
                                    still_missing.append(dep)
                                    installation_log.append(f"‚ùå {dep} installed but not importable")
                            else:
                                still_missing.append(dep)
                                installation_log.append(f"‚ùå {dep} installation failed")
                        
                        if still_missing and attempt < max_retries - 1:
                            logger.warning(f"‚è≥ Retrying with missing deps: {still_missing}")
                            time.sleep(2)
                            continue
                    else:
                        installation_log.append("All dependencies available")
                
                # Create execution wrapper
                python_exe = self._get_python_executable()
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp_file:
                    # Enhanced wrapper with better error handling
                    wrapped_code = f"""#!/usr/bin/env python3
import sys
import os

# Add system paths for modules
sys.path.insert(0, '/usr/local/lib/python3.8/site-packages')
sys.path.insert(0, '/usr/local/lib/python3.9/site-packages')
sys.path.insert(0, '/usr/local/lib/python3.10/site-packages')
sys.path.insert(0, '/usr/local/lib/python3.11/site-packages')

# Handle target IP argument
target_ip = "{target_ip}"
if len(sys.argv) > 1:
    target_ip = sys.argv[1]

# CVE ID for reference
cve_id = "{cve_id}"

# Autonomous dependency installation log
print("=== BreachPilot Autonomous Execution (Attempt {attempt + 1}) ===")
{chr(10).join([f'print("{log}")' for log in installation_log])}
print("="*50)

# Test imports before execution
print("Testing required imports...")
import_errors = []

{self._generate_import_tests(dependencies)}

if import_errors:
    print("‚ùå Import test failures:")
    for error in import_errors:
        print(f"  - {{error}}")
    print("BreachPilot will attempt to continue execution...")

print("üöÄ Starting PoC execution...")
print("-" * 40)

# Original PoC code with enhanced error handling
try:
{chr(10).join(['    ' + line for line in code.split(chr(10))])}
    print("-" * 40)
    print("‚úÖ PoC execution completed")
except ImportError as e:
    print(f"‚ùå Import Error: {{e}}")
    print("Missing dependency detected. BreachPilot's autonomous system will retry.")
    sys.exit(2)  # Special exit code for missing dependencies
except Exception as e:
    print(f"üí• Execution error: {{e}}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
"""
                    tmp_file.write(wrapped_code)
                    tmp_file.flush()
                    os.chmod(tmp_file.name, 0o755)
                    
                    # Execute with current Python
                    cmd = [python_exe, tmp_file.name, target_ip]
                    result = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        timeout=180,
                        env=self._get_enhanced_env()
                    )
                    
                    # Cleanup
                    try:
                        os.unlink(tmp_file.name)
                    except:
                        pass
                    
                    output = result.stdout + result.stderr
                    
                    # Add installation info to output
                    if installation_log:
                        output = f"Dependency Management:\n{chr(10).join(installation_log)}\n\n" + output
                    
                    # Check if we need to retry due to import errors
                    if result.returncode == 2 and attempt < max_retries - 1:
                        logger.warning(f"üîÑ Import error detected, retrying (attempt {attempt + 2})")
                        continue
                    
                    success = self._analyze_execution_success_enhanced(output, result.returncode, cve_id)
                    
                    return {
                        'success': success,
                        'output': output,
                        'error': result.stderr if not success else None,
                        'return_code': result.returncode,
                        'command': ' '.join(cmd),
                        'attempts': attempt + 1,
                        'dependencies_handled': len(dependencies) if dependencies else 0
                    }
                    
            except subprocess.TimeoutExpired:
                if attempt == max_retries - 1:
                    return {
                        'success': False,
                        'output': f'Execution timeout exceeded (180 seconds) after {max_retries} attempts',
                        'error': 'Timeout',
                        'return_code': -1,
                        'command': 'Timeout'
                    }
                else:
                    logger.warning(f"‚è∞ Timeout on attempt {attempt + 1}, retrying...")
                    continue
                    
            except Exception as e:
                if attempt == max_retries - 1:
                    return {
                        'success': False,
                        'output': f'Enhanced execution error after {max_retries} attempts: {str(e)}',
                        'error': str(e),
                        'return_code': -1,
                        'command': 'Error during execution'
                    }
                else:
                    logger.warning(f"üí• Exception on attempt {attempt + 1}: {e}")
                    continue
        
        # Should not reach here
        return {
            'success': False,
            'output': 'Maximum retry attempts exceeded',
            'error': 'Max retries exceeded',
            'return_code': -1,
            'command': 'Failed after retries'
        }
    
    def _generate_import_tests(self, dependencies: List[str]) -> str:
        """Generate import test code"""
        if not dependencies:
            return ""
        
        test_code = []
        for dep in dependencies:
            test_code.append(f"""
try:
    import {dep}
    print(f"‚úÖ {dep} import successful")
except ImportError as e:
    import_errors.append(f"{dep}: {{e}}")
    print(f"‚ùå {dep} import failed: {{e}}")
""")
        
        return "\n".join(test_code)
    
    def _get_enhanced_env(self) -> Dict[str, str]:
        """Get enhanced environment variables with Python paths"""
        env = os.environ.copy()
        
        # Add common Python paths
        python_paths = [
            '/usr/local/lib/python3.8/site-packages',
            '/usr/local/lib/python3.9/site-packages', 
            '/usr/local/lib/python3.10/site-packages',
            '/usr/local/lib/python3.11/site-packages',
            '/usr/lib/python3/dist-packages',
            '/home/user/.local/lib/python3.8/site-packages',
            '/home/user/.local/lib/python3.9/site-packages',
            '/home/user/.local/lib/python3.10/site-packages',
            '/home/user/.local/lib/python3.11/site-packages',
        ]
        
        existing_path = env.get('PYTHONPATH', '')
        if existing_path:
            python_paths.append(existing_path)
        
        env.update({
            'PYTHONPATH': ':'.join(python_paths),
            'PATH': '/usr/local/bin:/usr/bin:/bin',
            'HOME': '/tmp',
            'LANG': 'C.UTF-8',
            'LC_ALL': 'C.UTF-8',
        })
        
        return env
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute with enhancements"""
        try:
            import requests
            
            headers = {'User-Agent': 'Mozilla/5.0 (compatible; BreachPilot)'}
            response = requests.get(url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                content = response.text
                
                # Determine file type and execute
                return self._execute_poc_code_enhanced(content, target_ip, cve_id, poc_index)
            else:
                return {
                    'success': False,
                    'output': f'Failed to fetch from URL: {url} (HTTP {response.status_code})',
                    'error': f'HTTP {response.status_code}',
                    'return_code': -1,
                    'command': f'curl {url}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'URL fetch error: {str(e)}',
                'error': str(e),
                'return_code': -1,
                'command': f'curl {url}'
            }
    
    def _analyze_execution_success_enhanced(self, output: str, return_code: int, cve_id: str) -> bool:
        """Enhanced analysis to determine if execution was successful"""
        output_lower = output.lower()
        
        # General success indicators
        general_success_indicators = [
            'exploit successful', 'successfully exploited', 'shell obtained',
            'access granted', 'vulnerability confirmed', 'target vulnerable',
            'privilege escalation', 'authentication bypassed', 'payload executed',
            'exploit complete', 'pwned', 'compromised', 'backdoor installed',
            'reverse shell', 'meterpreter session', 'command executed',
            'poc execution completed'
        ]
        
        # Check general indicators
        if any(indicator in output_lower for indicator in general_success_indicators):
            return True
        
        # Check for failure indicators
        failure_indicators = [
            'failed', 'error', 'exception', 'not vulnerable',
            'access denied', 'connection refused', 'timeout',
            'traceback', 'syntax error', 'permission denied',
            'target is probably patched', 'attack failed', 'modulenotfounderror',
            'import error'
        ]
        
        if any(indicator in output_lower for indicator in failure_indicators):
            return False
        
        # Check return code and output length
        if return_code == 0 and len(output.strip()) > 20:
            # Look for positive indicators in the output
            positive_keywords = ['success', 'ok', 'done', 'complete', 'found', 'detected']
            if any(keyword in output_lower for keyword in positive_keywords):
                return True
        
        return False
    
    def _extract_artifacts_enhanced(self, output: str, cve_id: str) -> List[str]:
        """Extract security artifacts from exploit output"""
        artifacts = []
        import re
        
        # General patterns
        patterns = [
            (r'password[:\s]+([^\s\n]+)', 'Password'),
            (r'username[:\s]+([^\s\n]+)', 'Username'),
            (r'hash[:\s]+([a-f0-9]{32,})', 'Hash'),
            (r'token[:\s]+([^\s\n]+)', 'Token'),
            (r'session[:\s]+([^\s\n]+)', 'Session ID'),
            (r'credential[s]?[:\s]+([^\n]+)', 'Credentials'),
            (r'secret[:\s]+([^\s\n]+)', 'Secret'),
            (r'key[:\s]+([^\s\n]+)', 'Key'),
            (r'admin[:\s]+([^\s\n]+)', 'Admin Access'),
            (r'shell[:\s]+([^\s\n]+)', 'Shell Access'),
        ]
        
        # Apply general patterns
        for pattern, artifact_type in patterns:
            matches = re.finditer(pattern, output, re.IGNORECASE)
            for match in matches:
                artifacts.append(f"{artifact_type}: {match.group(1)}")
        
        # Look for file paths or URLs
        file_patterns = [
            r'/[^\s]+\.(?:txt|log|conf|cfg|ini|xml|json)',
            r'[a-zA-Z]:\\[^\s]+\.(?:txt|log|conf|cfg|ini|xml|json)',
            r'https?://[^\s]+',
        ]
        
        for pattern in file_patterns:
            matches = re.finditer(pattern, output)
            for match in matches:
                artifacts.append(f"File/URL: {match.group()}")
        
        return list(set(artifacts))[:10]  # Remove duplicates and limit
    
    def _identify_success_indicators_enhanced(self, output: str, cve_id: str) -> List[str]:
        """Identify success indicators from exploit output"""
        indicators = []
        output_lower = output.lower()
        
        # General success patterns
        general_patterns = [
            'exploit successful', 'shell obtained', 'access granted', 'login successful',
            'authentication bypassed', 'privilege escalation', 'vulnerability confirmed',
            'target vulnerable', 'exploit complete', 'payload executed', 'backdoor installed'
        ]
        
        # Check general patterns
        for pattern in general_patterns:
            if pattern in output_lower:
                indicators.append(pattern.title())
        
        return list(set(indicators))[:5]  # Remove duplicates and limit
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result to file"""
        try:
            filename = f"{target_ip}_exploit_{cve_id}_{poc_index}.json"
            filepath = config.DATA_DIR / filename
            
            with open(filepath, 'w') as f:
                json.dump(result.dict(), f, indent=2, default=str)
        except Exception as e:
            logger.warning(f"Failed to save exploit result: {e}")
    
    def cleanup(self):
        """Clean up resources"""
        if hasattr(self, 'git_executor'):
            self.git_executor.cleanup()
    
    def __del__(self):
        """Ensure cleanup on destruction"""
        try:
            self.cleanup()
        except:
            pass
