import json
import subprocess
import tempfile
import os
from typing import List, Dict, Any
from crewai import Agent, Task, Crew, Process
from langchain_openai import ChatOpenAI
from backend.models import ExploitResult, PoCResult, StepStatus
from backend.config import config
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.llm = ChatOpenAI(
            model=config.LLM_MODEL,
            temperature=0.1,  # Low temperature for precise execution
            api_key=config.OPENAI_API_KEY
        )
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits"""
        logger.info(f"="*50)
        logger.info(f"Starting exploitation for {target_ip}")
        logger.info(f"Approved PoCs: {[p.cve_id for p in approved_pocs]}")
        logger.info(f"="*50)
        
        results = []
        
        for poc in approved_pocs:
            logger.info(f"Executing exploit for {poc.cve_id}...")
            result = self._execute_single_exploit(target_ip, poc)
            results.append(result)
            self._save_exploit_result(target_ip, poc.cve_id, result)
        
        logger.info(f"="*50)
        logger.info(f"Exploitation complete: {len(results)} exploits executed")
        logger.info(f"="*50)
        
        return results
    
    def _execute_single_exploit(self, target_ip: str, poc: PoCResult) -> ExploitResult:
        """Execute a single exploit with enhanced AI-powered analysis and adaptation"""
        result = ExploitResult(
            cve_id=poc.cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING
        )
        
        try:
            # Step 1: Create Code Analysis Agent
            analysis_agent = Agent(
                role='Exploit Code Analyst',
                goal=f'Analyze and understand the PoC exploit code for {poc.cve_id}',
                backstory="""You are an expert security researcher who specializes in analyzing 
                proof-of-concept exploit code. You understand various programming languages, 
                exploit techniques, and can identify key components, dependencies, and execution 
                requirements of exploit code.""",
                llm=self.llm,
                verbose=True
            )
            
            # Step 2: Create Exploit Adaptation Agent
            adaptation_agent = Agent(
                role='Exploit Adaptation Engineer',
                goal=f'Adapt the analyzed exploit code for target {target_ip}',
                backstory="""You are an expert penetration tester who specializes in adapting 
                proof-of-concept exploits to specific target systems. You modify exploit code 
                for different environments, handle dependencies, and ensure safe execution.""",
                llm=self.llm,
                verbose=True
            )
            
            # Step 3: Create Execution Agent
            execution_agent = Agent(
                role='Exploit Execution Specialist',
                goal=f'Execute the adapted exploit against {target_ip} safely',
                backstory="""You are an expert in safely executing exploits in controlled 
                environments. You handle execution errors, capture output, and ensure proper 
                cleanup after exploit execution.""",
                llm=self.llm,
                verbose=True
            )
            
            # Prepare exploit context
            exploit_context = self._prepare_exploit_context(target_ip, poc)
            
            # Task 1: Analyze the exploit code
            analysis_task = Task(
                description=f"""Analyze the following PoC exploit code and provide detailed analysis:
                
                CVE: {poc.cve_id}
                Target IP: {target_ip}
                PoC Source: {poc.selected_poc.source if poc.selected_poc else 'Unknown'}
                PoC URL: {poc.selected_poc.url if poc.selected_poc else 'Unknown'}
                
                {exploit_context}
                
                Your analysis should include:
                1. Programming language and framework used
                2. Key functions and attack vectors
                3. Required dependencies and libraries
                4. Input parameters and configuration
                5. Expected output and success indicators
                6. Potential risks and safety considerations
                7. Execution environment requirements
                
                Provide a structured analysis in JSON format.""",
                agent=analysis_agent,
                expected_output="Structured analysis of the exploit code"
            )
            
            # Task 2: Adapt the exploit for the target
            adaptation_task = Task(
                description=f"""Based on the analysis, adapt the exploit code for target {target_ip}:
                
                Your adaptation should:
                1. Update target IP/URL to {target_ip}
                2. Handle missing dependencies gracefully
                3. Add proper error handling and logging
                4. Ensure safe execution (non-destructive if possible)
                5. Add timeout mechanisms
                6. Include success/failure detection
                7. Generate executable Python/Bash code
                
                CRITICAL: Output ONLY the executable code wrapped in ```python or ```bash code blocks. 
                Do NOT include any explanations, analysis, or markdown formatting outside the code blocks.
                Example format:
                ```python
                import sys
                # your code here
                ```
                """,
                agent=adaptation_agent,
                expected_output="Executable code in code blocks only"
            )
            
            # Task 3: Execute the exploit safely
            execution_task = Task(
                description=f"""Execute the adapted exploit code against {target_ip}:
                
                Your execution should:
                1. Run the exploit in a controlled environment
                2. Capture all output (stdout, stderr)
                3. Monitor for success indicators
                4. Handle execution errors gracefully
                5. Provide detailed execution report
                
                Output the execution results and analysis.""",
                agent=execution_agent,
                expected_output="Execution results and analysis"
            )
            
            # Create and run crew with sequential process
            crew = Crew(
                agents=[analysis_agent, adaptation_agent, execution_agent],
                tasks=[analysis_task, adaptation_task, execution_task],
                process=Process.sequential,
                verbose=True
            )
            
            crew_result = crew.kickoff()
            
            # Try to use the original PoC code if available, otherwise use AI-generated code
            if poc.selected_poc and poc.selected_poc.code:
                logger.info(f"Using original PoC code for {poc.cve_id}")
                execution_result = self._execute_exploit_code(poc.selected_poc.code, target_ip)
            else:
                logger.info(f"Using AI-generated code for {poc.cve_id}")
                execution_result = self._execute_exploit_code(str(crew_result), target_ip)
            
            result.exploit_used = poc.selected_poc.source if poc.selected_poc else "AI-Generated"
            result.execution_output = execution_result['output']
            result.success = execution_result['success']
            result.status = StepStatus.COMPLETED if execution_result['success'] else StepStatus.FAILED
            
            if result.success:
                logger.info(f"✓ Exploit {poc.cve_id} executed successfully")
                result.artifacts_captured = self._extract_artifacts(execution_result['output'])
            else:
                logger.warning(f"✗ Exploit {poc.cve_id} failed: {execution_result['error']}")
            
        except Exception as e:
            logger.error(f"Failed to execute exploit for {poc.cve_id}: {e}")
            result.status = StepStatus.FAILED
            result.execution_output = str(e)
        
        return result
    
    def _prepare_exploit_context(self, target_ip: str, poc: PoCResult) -> str:
        """Prepare context for exploit adaptation"""
        context = f"Target: {target_ip}\n"
        
        if poc.selected_poc:
            context += f"PoC Description: {poc.selected_poc.description}\n"
            context += f"PoC Source: {poc.selected_poc.source}\n"
            context += f"PoC URL: {poc.selected_poc.url}\n"
            
            # Use the code we already fetched during PoC search
            if poc.selected_poc.code:
                context += f"\nOriginal PoC Code:\n```python\n{poc.selected_poc.code}\n```\n"
            else:
                # Try to fetch exploit code from URL as fallback
                try:
                    import requests
                    response = requests.get(poc.selected_poc.url, timeout=10)
                    if response.status_code == 200:
                        # Check if it's a GitHub raw URL
                        if 'raw.githubusercontent.com' in poc.selected_poc.url or '.py' in poc.selected_poc.url:
                            context += f"\nOriginal PoC Code:\n```\n{response.text[:2000]}\n```\n"
                        else:
                            context += f"\nPoC available at: {poc.selected_poc.url}\n"
                except:
                    context += f"\nPoC URL: {poc.selected_poc.url}\n"
        
        return context
    
    def _execute_exploit_code(self, code: str, target_ip: str) -> Dict[str, Any]:
        """Execute the exploit code in a sandboxed environment with enhanced analysis"""
        try:
            # Extract actual executable code from AI response
            executable_code = self._extract_executable_code(code)
            
            if not executable_code:
                logger.warning("No executable code found in AI response")
                return {
                    'success': False,
                    'output': 'No executable code found in AI response',
                    'error': 'AI response did not contain executable code'
                }
            
            # Determine language and prepare execution
            language = self._detect_language(executable_code)
            logger.info(f"Detected language: {language}")
            
            if language == 'python':
                return self._execute_python_exploit(executable_code, target_ip)
            elif language == 'bash':
                return self._execute_bash_exploit(executable_code, target_ip)
            else:
                # Try to execute as Python first, then Bash
                result = self._execute_python_exploit(executable_code, target_ip)
                if not result['success']:
                    result = self._execute_bash_exploit(executable_code, target_ip)
                return result
            
        except Exception as e:
            return {
                'success': False,
                'output': str(e),
                'error': str(e)
            }
    
    def _extract_executable_code(self, ai_response: str) -> str:
        """Extract executable code from AI response, handling various formats"""
        try:
            # Method 1: Look for code blocks in markdown
            if '```' in ai_response:
                code_blocks = ai_response.split('```')
                for i, block in enumerate(code_blocks):
                    if i % 2 == 1:  # Odd indices are code blocks
                        block = block.strip()
                        # Skip language specifiers
                        if block.startswith('python') or block.startswith('bash'):
                            block = '\n'.join(block.split('\n')[1:])
                        # Check if this looks like executable code
                        if self._is_executable_code(block):
                            return block
            
            # Method 2: Look for Python-like code patterns
            lines = ai_response.split('\n')
            code_lines = []
            in_code_section = False
            
            for line in lines:
                line = line.strip()
                # Start of code section
                if any(keyword in line.lower() for keyword in ['import ', 'def ', 'class ', '#!/bin/bash', '#!/bin/sh']):
                    in_code_section = True
                    code_lines.append(line)
                # Continue code section
                elif in_code_section:
                    if line and not line.startswith('**') and not line.startswith('-') and not line.startswith('#'):
                        code_lines.append(line)
                    elif line.startswith('**') or line.startswith('#'):
                        # End of code section
                        break
            
            if code_lines:
                potential_code = '\n'.join(code_lines)
                if self._is_executable_code(potential_code):
                    return potential_code
            
            # Method 3: Try to find any Python/Bash code patterns
            import re
            python_pattern = r'(import\s+\w+|def\s+\w+|class\s+\w+).*?(?=\n\n|\n\*\*|$)'
            bash_pattern = r'(#!/bin/bash|#!/bin/sh|curl\s+|wget\s+|nc\s+).*?(?=\n\n|\n\*\*|$)'
            
            python_match = re.search(python_pattern, ai_response, re.DOTALL)
            bash_match = re.search(bash_pattern, ai_response, re.DOTALL)
            
            if python_match and self._is_executable_code(python_match.group(0)):
                return python_match.group(0)
            elif bash_match and self._is_executable_code(bash_match.group(0)):
                return bash_match.group(0)
            
            return ""
            
        except Exception as e:
            logger.error(f"Error extracting executable code: {e}")
            return ""
    
    def _is_executable_code(self, code: str) -> bool:
        """Check if the extracted text looks like executable code"""
        if not code or len(code.strip()) < 10:
            return False
        
        code_lower = code.lower()
        
        # Python indicators
        python_indicators = ['import ', 'def ', 'class ', 'from ', 'if __name__', 'print(']
        python_score = sum(1 for indicator in python_indicators if indicator in code_lower)
        
        # Bash indicators
        bash_indicators = ['#!/bin/bash', '#!/bin/sh', 'curl ', 'wget ', 'nc ', 'nmap ', 'ssh ']
        bash_score = sum(1 for indicator in bash_indicators if indicator in code_lower)
        
        # Check for non-code content
        non_code_indicators = ['**', '##', '###', 'execution results', 'analysis:', 'conclusion:']
        non_code_score = sum(1 for indicator in non_code_indicators if indicator in code_lower)
        
        # Must have code indicators and minimal non-code content
        return (python_score > 0 or bash_score > 0) and non_code_score < 3
    
    def _clean_python_code(self, code: str) -> str:
        """Clean and format Python code for execution"""
        try:
            lines = code.split('\n')
            cleaned_lines = []
            indent_level = 0
            
            for line in lines:
                # Remove leading/trailing whitespace
                original_line = line
                line = line.rstrip()
                
                # Skip empty lines at the beginning
                if not cleaned_lines and not line:
                    continue
                
                # Calculate current indentation
                current_indent = len(line) - len(line.lstrip())
                
                # Fix indentation based on context
                if line.strip():
                    # If this is the first non-empty line, remove all indentation
                    if not any(cleaned_lines):
                        line = line.lstrip()
                        indent_level = 0
                    else:
                        # Maintain proper indentation relative to the try block
                        if 'try:' in line or 'except:' in line or 'finally:' in line:
                            line = line.lstrip()
                        elif line.strip().startswith('import ') or line.strip().startswith('from '):
                            line = line.lstrip()
                        elif line.strip().startswith('def ') or line.strip().startswith('class '):
                            line = line.lstrip()
                        elif line.strip().startswith('if ') and '__name__' in line:
                            line = line.lstrip()
                        else:
                            # Keep relative indentation for other lines
                            if current_indent > 0:
                                line = '    ' + line.lstrip()
                
                cleaned_lines.append(line)
            
            # Remove trailing empty lines
            while cleaned_lines and not cleaned_lines[-1]:
                cleaned_lines.pop()
            
            return '\n'.join(cleaned_lines)
            
        except Exception as e:
            logger.error(f"Error cleaning Python code: {e}")
            return code
    
    def _is_original_poc_code(self, code: str) -> bool:
        """Check if this is original PoC code (not AI-generated)"""
        # Look for indicators that this is original PoC code
        original_indicators = [
            '#!/usr/bin/env python',
            '#!/usr/bin/python',
            'import impacket',
            'from impacket',
            'class ',
            'def main(',
            'if __name__ == "__main__"'
        ]
        
        code_lower = code.lower()
        return any(indicator.lower() in code_lower for indicator in original_indicators)
    
    def _install_dependencies(self, code: str):
        """Install required dependencies for the exploit code"""
        try:
            # Common penetration testing dependencies
            dependencies = {
                'impacket': 'impacket',
                'scapy': 'scapy',
                'cryptography': 'cryptography',
                'paramiko': 'paramiko',
                'requests': 'requests',
                'beautifulsoup4': 'beautifulsoup4',
                'lxml': 'lxml',
                'dnspython': 'dnspython',
                'python-nmap': 'python-nmap',
                'shodan': 'shodan',
                'python-whois': 'python-whois'
            }
            
            # Check which dependencies are needed
            code_lower = code.lower()
            needed_deps = []
            
            for dep_name, pip_name in dependencies.items():
                if f'import {dep_name}' in code_lower or f'from {dep_name}' in code_lower:
                    needed_deps.append(pip_name)
            
            # Install missing dependencies
            for dep in needed_deps:
                try:
                    logger.info(f"Installing dependency: {dep}")
                    result = subprocess.run(
                        ['pip', 'install', dep],
                        capture_output=True,
                        text=True,
                        timeout=60
                    )
                    if result.returncode == 0:
                        logger.info(f"Successfully installed {dep}")
                    else:
                        logger.warning(f"Failed to install {dep}: {result.stderr}")
                except Exception as e:
                    logger.warning(f"Error installing {dep}: {e}")
                    
        except Exception as e:
            logger.error(f"Error in dependency installation: {e}")
    
    def _detect_language(self, code: str) -> str:
        """Detect the programming language of the exploit code"""
        code_lower = code.lower()
        
        # Python indicators
        python_indicators = ['import ', 'def ', 'class ', 'from ', 'if __name__', 'print(', 'sys.']
        python_score = sum(1 for indicator in python_indicators if indicator in code_lower)
        
        # Bash indicators
        bash_indicators = ['#!/bin/bash', '#!/bin/sh', 'curl ', 'wget ', 'nc ', 'nmap ', 'ssh ', 'telnet ']
        bash_score = sum(1 for indicator in bash_indicators if indicator in code_lower)
        
        if python_score > bash_score:
            return 'python'
        elif bash_score > 0:
            return 'bash'
        else:
            return 'unknown'
    
    def _execute_python_exploit(self, code: str, target_ip: str) -> Dict[str, Any]:
        """Execute Python exploit code"""
        try:
            # Check and install dependencies first
            self._install_dependencies(code)
            
            # Create a proper exploit directory structure
            exploit_dir = config.DATA_DIR / "exploits"
            exploit_dir.mkdir(exist_ok=True)
            
            # Generate unique filename
            import uuid
            exploit_id = str(uuid.uuid4())[:8]
            script_path = exploit_dir / f"exploit_{exploit_id}.py"
            
            # For original PoC code, use it directly with minimal modifications
            if self._is_original_poc_code(code):
                # Add target IP as command line argument if not already present
                if 'sys.argv' not in code:
                    # Properly indent the code and avoid duplicate imports
                    lines = code.split('\n')
                    indented_lines = []
                    for line in lines:
                        if line.strip() and not line.strip().startswith('import sys'):
                            indented_lines.append('    ' + line)
                        elif line.strip().startswith('import sys'):
                            # Skip duplicate sys import
                            continue
                        else:
                            indented_lines.append(line)
                    indented_code = '\n'.join(indented_lines)
                    code = f"{indented_code}\n    if len(sys.argv) > 1:\n        target_ip = sys.argv[1]\n"
                
                # Add basic error handling
                safe_code = f"""#!/usr/bin/env python3
import sys
import traceback
import signal

def timeout_handler(signum, frame):
    raise TimeoutError("Exploit execution timed out")

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(60)

try:
{code}
except Exception as e:
    print(f"Error: {{e}}")
    traceback.print_exc()
finally:
    signal.alarm(0)
"""
            else:
                # For AI-generated code, clean and format it
                cleaned_code = self._clean_python_code(code)
                safe_code = f"""#!/usr/bin/env python3
import sys
import traceback
import signal

def timeout_handler(signum, frame):
    raise TimeoutError("Exploit execution timed out")

signal.signal(signal.SIGALRM, timeout_handler)
signal.alarm(60)

try:
{cleaned_code}
except Exception as e:
    print(f"Error: {{e}}")
    traceback.print_exc()
finally:
    signal.alarm(0)
"""
            
            # Write to file
            with open(script_path, 'w') as f:
                f.write(safe_code)
            
            # Make executable
            os.chmod(script_path, 0o755)
            
            logger.info(f"Executing Python exploit: {script_path}")
            logger.info(f"Command: python3 {script_path} {target_ip}")
            
            result = subprocess.run(
                ['python3', str(script_path), target_ip],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            # Keep the exploit file for debugging (don't delete immediately)
            logger.info(f"Exploit file saved at: {script_path}")
            
            output = result.stdout + result.stderr
            success = self._analyze_success(output, result.returncode)
            
            return {
                'success': success,
                'output': output,
                'error': None if success else result.stderr
            }
            
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': 'Exploit execution timed out after 60 seconds',
                'error': 'Timeout'
            }
        except Exception as e:
            return {
                'success': False,
                'output': str(e),
                'error': str(e)
            }
    
    def _execute_bash_exploit(self, code: str, target_ip: str) -> Dict[str, Any]:
        """Execute Bash exploit code"""
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
                # Add safety and error handling
                safe_code = f"""#!/bin/bash
set -e
set -o pipefail

# Timeout mechanism
timeout 60 bash -c '
{code}
' || echo "Exploit execution timed out or failed"
"""
                f.write(safe_code)
                script_path = f.name
                
                os.chmod(script_path, 0o755)
                logger.info(f"Executing Bash exploit: {script_path}")
                
                result = subprocess.run(
                    [script_path, target_ip],
                    capture_output=True,
                    text=True,
                timeout=60
                )
                
                os.unlink(script_path)
            
            output = result.stdout + result.stderr
            success = self._analyze_success(output, result.returncode)
            
            return {
                'success': success,
                'output': output,
                'error': None if success else result.stderr
            }
            
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': 'Exploit execution timed out after 60 seconds',
                'error': 'Timeout'
            }
        except Exception as e:
            return {
                'success': False,
                'output': str(e),
                'error': str(e)
            }
    
    def _analyze_success(self, output: str, return_code: int) -> bool:
        """Analyze exploit output to determine success"""
        output_lower = output.lower()
        
        # Success indicators
        success_indicators = [
            'success', 'vulnerable', 'exploited', 'compromised', 'shell', 'access',
            'logged in', 'authenticated', 'bypassed', 'elevated', 'root', 'admin',
            'connection established', 'payload delivered', 'code executed'
        ]
        
        # Failure indicators
        failure_indicators = [
            'failed', 'error', 'timeout', 'connection refused', 'permission denied',
            'not vulnerable', 'not exploitable', 'access denied', 'authentication failed'
        ]
        
        success_score = sum(1 for indicator in success_indicators if indicator in output_lower)
        failure_score = sum(1 for indicator in failure_indicators if indicator in output_lower)
        
        # Return code 0 is generally good, but check content too
        if return_code == 0 and success_score > failure_score:
            return True
        elif success_score > 0 and success_score > failure_score:
            return True
        else:
            return False
    
    def _extract_artifacts(self, output: str) -> List[str]:
        """Extract important artifacts from exploit output"""
        artifacts = []
        
        # Look for common indicators
        patterns = [
            r'(password|passwd|pwd):\s*([\w\d]+)',
            r'(token|key|secret):\s*([\w\d-]+)',
            r'(shell|access|connection)\s+(?:obtained|established|successful)',
            r'(?:192\.168\.\d+\.\d+|10\.\d+\.\d+\.\d+)',  # IP addresses
            r'(CVE-\d{4}-\d{4,7})\s+vulnerable'
        ]
        
        for pattern in patterns:
            import re
            matches = re.findall(pattern, output, re.IGNORECASE)
            if matches:
                artifacts.extend([str(m) for m in matches])
        
        return artifacts[:10]  # Limit to 10 artifacts
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult):
        """Save exploit result to JSON"""
        output_file = config.DATA_DIR / f"{target_ip}_exploit_{cve_id.replace('-', '_')}.json"
        with open(output_file, 'w') as f:
            json.dump(result.model_dump(), f, indent=2, default=str)
        logger.info(f"Exploit result saved to {output_file}")
