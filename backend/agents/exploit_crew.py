import json
import subprocess
import tempfile
import os
import time
from typing import List, Dict, Any, Optional
from crewai import Agent, Task, Crew, Process
from langchain_openai import ChatOpenAI
from backend.models import ExploitResult, PoCResult, PoCInfo, StepStatus
from backend.config import config
import logging

logger = logging.getLogger(__name__)

class ExploitCrew:
    def __init__(self):
        self.llm = ChatOpenAI(
            model=config.LLM_MODEL,
            temperature=0.1,
            api_key=config.OPENAI_API_KEY
        )
        self.exploits_dir = config.DATA_DIR / "exploits"
        self.exploits_dir.mkdir(exist_ok=True)
    
    def execute_single_poc_with_retry(self, target_ip: str, cve_id: str, poc_result: PoCResult) -> List[ExploitResult]:
        """Execute single CVE with multiple PoCs and auto-retry functionality"""
        logger.info(f"="*60)
        logger.info(f"Starting exploit execution for {cve_id} on {target_ip}")
        logger.info(f"Available PoCs: {len(poc_result.available_pocs)}")
        logger.info(f"="*60)
        
        all_results = []
        success_achieved = False
        
        for i, poc in enumerate(poc_result.available_pocs, 1):
            if success_achieved:
                logger.info(f"Success already achieved, skipping remaining PoCs")
                break
            
            logger.info(f"Attempting PoC #{i}/{len(poc_result.available_pocs)}: {poc.source}")
            
            result = self._execute_single_poc_enhanced(target_ip, cve_id, poc, i)
            all_results.append(result)
            
            if result.success:
                logger.info(f"✓ SUCCESS: PoC #{i} succeeded!")
                success_achieved = True
            else:
                logger.warning(f"✗ FAILED: PoC #{i} failed - {result.execution_output[:100]}...")
                if i < len(poc_result.available_pocs):
                    logger.info(f"Trying next PoC in 2 seconds...")
                    time.sleep(2)
        
        logger.info(f"="*60)
        logger.info(f"Exploit execution complete: {len(all_results)} attempts, {'SUCCESS' if success_achieved else 'ALL FAILED'}")
        logger.info(f"="*60)
        
        return all_results
    
    def execute_exploits(self, target_ip: str, approved_pocs: List[PoCResult]) -> List[ExploitResult]:
        """Execute approved PoC exploits with enhanced retry logic"""
        logger.info(f"Starting exploitation campaign for {target_ip}")
        all_results = []
        
        for poc_result in approved_pocs:
            results = self.execute_single_poc_with_retry(target_ip, poc_result.cve_id, poc_result)
            all_results.extend(results)
        
        return all_results
    
    def _execute_single_poc_enhanced(self, target_ip: str, cve_id: str, poc: PoCInfo, poc_index: int) -> ExploitResult:
        """Execute a single PoC with enhanced error handling and analysis"""
        result = ExploitResult(
            cve_id=cve_id,
            target_ip=target_ip,
            status=StepStatus.RUNNING,
            poc_index=poc_index,
            poc_source=poc.source,
            poc_url=poc.url
        )
        
        start_time = time.time()
        
        try:
            # Method 1: Use saved PoC file if available
            if hasattr(poc, 'filename') and poc.filename:
                logger.info(f"Executing saved PoC file: {poc.filename}")
                execution_result = self._execute_saved_poc_file(poc.filename, target_ip)
                result.exploit_used = f"Saved PoC: {poc.filename}"
            
            # Method 2: Execute code directly
            elif poc.code and poc.code.strip():
                logger.info(f"Executing PoC code directly")
                execution_result = self._execute_poc_code_enhanced(poc.code, target_ip, cve_id, poc_index)
                result.exploit_used = f"Direct execution: {poc.source}"
            
            # Method 3: Try to fetch and execute from URL
            else:
                logger.info(f"Attempting to fetch and execute from URL")
                execution_result = self._fetch_and_execute_from_url(poc.url, target_ip, cve_id, poc_index)
                result.exploit_used = f"URL fetch: {poc.url}"
            
            # Process execution results
            result.execution_output = execution_result.get('output', '')
            result.success = execution_result.get('success', False)
            result.execution_time = round(time.time() - start_time, 2)
            result.status = StepStatus.COMPLETED if result.success else StepStatus.FAILED
            
            # Enhanced success analysis
            if result.success:
                result.artifacts_captured = self._extract_artifacts_enhanced(result.execution_output)
                result.success_indicators = self._identify_success_indicators(result.execution_output)
                logger.info(f"✓ PoC #{poc_index} SUCCESS in {result.execution_time}s")
                if result.artifacts_captured:
                    logger.info(f"  Artifacts found: {result.artifacts_captured}")
            else:
                result.failure_reason = execution_result.get('error', 'Unknown error')
                logger.warning(f"✗ PoC #{poc_index} FAILED in {result.execution_time}s: {result.failure_reason}")
        
        except Exception as e:
            result.status = StepStatus.FAILED
            result.execution_output = f"Execution error: {str(e)}"
            result.failure_reason = str(e)
            result.execution_time = round(time.time() - start_time, 2)
            logger.error(f"PoC #{poc_index} execution exception: {e}")
        
        # Save individual exploit result
        self._save_exploit_result(target_ip, cve_id, result, poc_index)
        
        return result
    
    def _execute_saved_poc_file(self, filename: str, target_ip: str) -> Dict[str, Any]:
        """Execute a saved PoC file"""
        try:
            filepath = self.exploits_dir / filename
            
            if not filepath.exists():
                return {
                    'success': False,
                    'output': f'PoC file not found: {filename}',
                    'error': 'File not found'
                }
            
            # Determine execution method based on extension
            extension = filename.split('.')[-1].lower()
            
            if extension == 'py':
                return self._execute_python_file(filepath, target_ip)
            elif extension == 'sh':
                return self._execute_shell_file(filepath, target_ip)
            elif extension == 'rb':
                return self._execute_ruby_file(filepath, target_ip)
            elif extension == 'pl':
                return self._execute_perl_file(filepath, target_ip)
            else:
                return self._execute_generic_file(filepath, target_ip)
        
        except Exception as e:
            return {
                'success': False,
                'output': f'Error executing saved PoC: {str(e)}',
                'error': str(e)
            }
    
    def _execute_python_file(self, filepath, target_ip: str) -> Dict[str, Any]:
        """Execute Python PoC file"""
        try:
            logger.info(f"Executing Python file: {filepath}")
            
            # Try different execution patterns
            execution_patterns = [
                ['python3', str(filepath), target_ip],
                ['python3', str(filepath), '--target', target_ip],
                ['python3', str(filepath), '-t', target_ip],
                ['python3', str(filepath)]  # Without target argument
            ]
            
            for i, cmd in enumerate(execution_patterns, 1):
                try:
                    logger.debug(f"  Attempt #{i}: {' '.join(cmd)}")
                    
                    result = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        timeout=120,
                        cwd=self.exploits_dir
                    )
                    
                    output = result.stdout + result.stderr
                    success = self._analyze_success_enhanced(output, result.returncode)
                    
                    if success or i == len(execution_patterns):  # Return on success or last attempt
                        return {
                            'success': success,
                            'output': output,
                            'error': result.stderr if not success else None,
                            'command_used': ' '.join(cmd)
                        }
                        
                except subprocess.TimeoutExpired:
                    if i == len(execution_patterns):  # Last attempt
                        return {
                            'success': False,
                            'output': 'Python execution timed out after 120 seconds',
                            'error': 'Timeout'
                        }
                    continue
                except Exception as e:
                    if i == len(execution_patterns):
                        return {
                            'success': False,
                            'output': f'Python execution error: {str(e)}',
                            'error': str(e)
                        }
                    continue
        
        except Exception as e:
            return {
                'success': False,
                'output': f'Error in Python file execution: {str(e)}',
                'error': str(e)
            }
    
    def _execute_shell_file(self, filepath, target_ip: str) -> Dict[str, Any]:
        """Execute shell script PoC file"""
        try:
            # Make sure it's executable
            os.chmod(filepath, 0o755)
            
            execution_patterns = [
                ['bash', str(filepath), target_ip],
                ['bash', str(filepath), '--target', target_ip],
                ['bash', str(filepath)],
                ['sh', str(filepath), target_ip]
            ]
            
            for cmd in execution_patterns:
                try:
                    logger.debug(f"Shell execution: {' '.join(cmd)}")
                    
                    result = subprocess.run(
                        cmd,
                        capture_output=True,
                        text=True,
                        timeout=120,
                        cwd=self.exploits_dir
                    )
                    
                    output = result.stdout + result.stderr
                    success = self._analyze_success_enhanced(output, result.returncode)
                    
                    if success:
                        return {
                            'success': True,
                            'output': output,
                            'command_used': ' '.join(cmd)
                        }
                        
                except subprocess.TimeoutExpired:
                    continue
                except Exception:
                    continue
            
            return {
                'success': False,
                'output': f'All shell execution patterns failed for {filepath}',
                'error': 'All execution patterns failed'
            }
            
        except Exception as e:
            return {
                'success': False,
                'output': f'Shell execution error: {str(e)}',
                'error': str(e)
            }
    
    def _execute_ruby_file(self, filepath, target_ip: str) -> Dict[str, Any]:
        """Execute Ruby PoC file"""
        try:
            cmd = ['ruby', str(filepath), target_ip]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            output = result.stdout + result.stderr
            success = self._analyze_success_enhanced(output, result.returncode)
            
            return {
                'success': success,
                'output': output,
                'error': result.stderr if not success else None
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'output': 'Ruby execution timed out', 'error': 'Timeout'}
        except Exception as e:
            return {'success': False, 'output': f'Ruby execution error: {str(e)}', 'error': str(e)}
    
    def _execute_perl_file(self, filepath, target_ip: str) -> Dict[str, Any]:
        """Execute Perl PoC file"""
        try:
            cmd = ['perl', str(filepath), target_ip]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            output = result.stdout + result.stderr
            success = self._analyze_success_enhanced(output, result.returncode)
            
            return {
                'success': success,
                'output': output,
                'error': result.stderr if not success else None
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'output': 'Perl execution timed out', 'error': 'Timeout'}
        except Exception as e:
            return {'success': False, 'output': f'Perl execution error: {str(e)}', 'error': str(e)}
    
    def _execute_generic_file(self, filepath, target_ip: str) -> Dict[str, Any]:
        """Execute generic executable file"""
        try:
            os.chmod(filepath, 0o755)
            cmd = [str(filepath), target_ip]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            output = result.stdout + result.stderr
            success = self._analyze_success_enhanced(output, result.returncode)
            
            return {
                'success': success,
                'output': output,
                'error': result.stderr if not success else None
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'output': 'Generic execution timed out', 'error': 'Timeout'}
        except Exception as e:
            return {'success': False, 'output': f'Generic execution error: {str(e)}', 'error': str(e)}
    
    def _execute_poc_code_enhanced(self, code: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Execute PoC code with enhanced processing"""
        try:
            # Create dynamic filename
            cve_clean = cve_id.replace('CVE-', '').replace('cve-', '')
            extension = self._detect_file_extension(code)
            filename = f"cve-{cve_clean}-{poc_index:03d}.{extension}"
            filepath = self.exploits_dir / filename
            
            # Prepare code with target IP injection
            processed_code = self._inject_target_ip(code, target_ip)
            
            # Add safety wrapper and metadata
            safe_code = self._wrap_code_safely(processed_code, cve_id, target_ip)
            
            # Save to file
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(safe_code)
            
            os.chmod(filepath, 0o755)
            
            # Execute based on file type
            if extension == 'py':
                return self._execute_python_file(filepath, target_ip)
            elif extension == 'sh':
                return self._execute_shell_file(filepath, target_ip)
            elif extension == 'rb':
                return self._execute_ruby_file(filepath, target_ip)
            elif extension == 'pl':
                return self._execute_perl_file(filepath, target_ip)
            else:
                return self._execute_generic_file(filepath, target_ip)
                
        except Exception as e:
            return {
                'success': False,
                'output': f'Code execution error: {str(e)}',
                'error': str(e)
            }
    
    def _fetch_and_execute_from_url(self, url: str, target_ip: str, cve_id: str, poc_index: int) -> Dict[str, Any]:
        """Fetch code from URL and execute"""
        try:
            import requests
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=15)
            if response.status_code == 200:
                code = response.text
                
                # Only proceed if it looks like executable code
                if self._is_executable_code(code):
                    return self._execute_poc_code_enhanced(code, target_ip, cve_id, poc_index)
                else:
                    return {
                        'success': False,
                        'output': f'URL content does not appear to be executable code: {url}',
                        'error': 'Not executable code'
                    }
            else:
                return {
                    'success': False,
                    'output': f'Failed to fetch from URL: {url} (status: {response.status_code})',
                    'error': f'HTTP {response.status_code}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'output': f'URL fetch error: {str(e)}',
                'error': str(e)
            }
    
    def _inject_target_ip(self, code: str, target_ip: str) -> str:
        """Intelligently inject target IP into code"""
        try:
            # Common patterns to replace with target IP
            patterns = [
                (r'target\s*=\s*["\']([^"\']+)["\']', f'target = "{target_ip}"'),
                (r'host\s*=\s*["\']([^"\']+)["\']', f'host = "{target_ip}"'),
                (r'TARGET_IP\s*=\s*["\']([^"\']+)["\']', f'TARGET_IP = "{target_ip}"'),
                (r'rhost\s*=\s*["\']([^"\']+)["\']', f'rhost = "{target_ip}"'),
                (r'RHOST\s*=\s*["\']([^"\']+)["\']', f'RHOST = "{target_ip}"'),
                # Common example IPs to replace
                (r'192\.168\.1\.1\d+', target_ip),
                (r'10\.0\.0\.\d+', target_ip),
                (r'127\.0\.0\.1', target_ip),
                (r'localhost', target_ip),
            ]
            
            modified_code = code
            for pattern, replacement in patterns:
                import re
                if re.search(pattern, modified_code):
                    modified_code = re.sub(pattern, replacement, modified_code)
                    logger.debug(f"Replaced pattern: {pattern}")
            
            # If no patterns matched, try to add target IP as argument
            if 'sys.argv' not in modified_code and 'ARGV' not in modified_code:
                if modified_code.strip().startswith('#!/usr/bin/env python') or 'import' in modified_code:
                    # Python code
                    modified_code = f"""import sys
target_ip = "{target_ip}" if len(sys.argv) <= 1 else sys.argv[1]

{modified_code}"""
            
            return modified_code
            
        except Exception as e:
            logger.warning(f"Error injecting target IP: {e}")
            return code
    
    def _wrap_code_safely(self, code: str, cve_id: str, target_ip: str) -> str:
        """Wrap code with safety measures and metadata"""
        try:
            extension = self._detect_file_extension(code)
            
            if extension == 'py':
                return f"""#!/usr/bin/env python3
# CVE: {cve_id}
# Target: {target_ip}
# Generated by BreachPilot
# Execution timeout: 120 seconds

import sys
import signal
import traceback
from datetime import datetime

def timeout_handler(signum, frame):
    print(f"[TIMEOUT] Exploit execution timed out after 120 seconds")
    sys.exit(1)

def main():
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(120)
    
    try:
        print(f"[START] Starting exploit execution at {{datetime.now()}}")
        print(f"[TARGET] Target IP: {target_ip}")
        print(f"[CVE] CVE ID: {cve_id}")
        print("-" * 50)
        
{self._indent_code(code, 8)}
        
        print("-" * 50)
        print(f"[SUCCESS] Exploit execution completed successfully")
        
    except KeyboardInterrupt:
        print(f"[INTERRUPTED] Execution interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] Exploit execution failed: {{str(e)}}")
        traceback.print_exc()
        sys.exit(1)
    finally:
        signal.alarm(0)

if __name__ == "__main__":
    main()
"""
            elif extension == 'sh':
                return f"""#!/bin/bash
# CVE: {cve_id}
# Target: {target_ip}
# Generated by BreachPilot

set -e
set -o pipefail

TARGET_IP="{target_ip}"

echo "[START] Starting exploit execution at $(date)"
echo "[TARGET] Target IP: $TARGET_IP"
echo "[CVE] CVE ID: {cve_id}"
echo "$(printf '%.0s-' {{1..50}})"

timeout 120 bash -c '{code.replace("'", "'\\''")}' || {{
    echo "[ERROR] Exploit execution failed or timed out"
    exit 1
}}

echo "$(printf '%.0s-' {{1..50}})"
echo "[SUCCESS] Exploit execution completed"
"""
            else:
                return f"""# CVE: {cve_id}
# Target: {target_ip}
# Generated by BreachPilot

{code}
"""
        except Exception as e:
            logger.warning(f"Error wrapping code safely: {e}")
            return code
    
    def _indent_code(self, code: str, spaces: int) -> str:
        """Indent code for proper Python structure"""
        try:
            lines = code.split('\n')
            indented_lines = []
            
            for line in lines:
                if line.strip():
                    indented_lines.append(' ' * spaces + line)
                else:
                    indented_lines.append('')
            
            return '\n'.join(indented_lines)
        except:
            return code
    
    def _detect_file_extension(self, code: str) -> str:
        """Detect appropriate file extension"""
        code_lower = code.lower()
        
        if any(keyword in code_lower for keyword in ['import ', 'def ', 'class ', 'from ', 'print(']):
            return 'py'
        elif any(keyword in code_lower for keyword in ['#!/bin/bash', '#!/bin/sh', 'curl ', 'wget ', 'echo ']):
            return 'sh'
        elif any(keyword in code_lower for keyword in ['require ', 'def ', 'class ', 'puts ', 'ruby']):
            return 'rb'
        elif any(keyword in code_lower for keyword in ['use ', 'sub ', 'my ', 'perl']):
            return 'pl'
        else:
            return 'py'  # Default to Python
    
    def _is_executable_code(self, code: str) -> bool:
        """Check if content appears to be executable code"""
        if not code or len(code.strip()) < 20:
            return False
        
        code_lower = code.lower()
        
        # Code indicators
        code_indicators = [
            'import ', 'def ', 'class ', 'from ', 'if ', 'for ', 'while ',
            '#!/bin/bash', '#!/bin/sh', '#!/usr/bin/python',
            'curl ', 'wget ', 'nc ', 'nmap ', 'ssh ',
            'require ', 'puts ', 'def ', '$',
            'use ', 'sub ', 'my '
        ]
        
        indicator_count = sum(1 for indicator in code_indicators if indicator in code_lower)
        
        # Non-code indicators
        non_code_indicators = ['<html', '<div', '<script', 'http://']
        non_code_count = sum(1 for indicator in non_code_indicators if indicator in code_lower)
        
        return indicator_count >= 2 and non_code_count == 0
    
    def _analyze_success_enhanced(self, output: str, return_code: int) -> bool:
        """Enhanced success analysis with multiple indicators"""
        output_lower = output.lower()
        
        # Strong success indicators
        strong_success = [
            'exploit successful', 'exploitation successful', 'successfully exploited',
            'shell obtained', 'access granted', 'login successful', 'authentication bypassed',
            'privilege escalation successful', 'root access', 'admin access',
            'payload executed', 'code execution successful', 'remote code execution',
            'vulnerability confirmed', 'target is vulnerable'
        ]
        
        # Weak success indicators
        weak_success = [
            'success', 'vulnerable', 'exploited', 'compromised', 'shell', 'access',
            'connected', 'established', 'authenticated', 'bypassed', 'elevated'
        ]
        
        # Failure indicators
        failure_indicators = [
            'failed', 'error', 'timeout', 'connection refused', 'permission denied',
            'not vulnerable', 'not exploitable', 'access denied', 'authentication failed',
            'exploit failed', 'connection timeout', 'no route to host'
        ]
        
        # Count indicators
        strong_success_count = sum(1 for indicator in strong_success if indicator in output_lower)
        weak_success_count = sum(1 for indicator in weak_success if indicator in output_lower)
        failure_count = sum(1 for indicator in failure_indicators if indicator in output_lower)
        
        # Decision logic
        if strong_success_count > 0:
            return True
        elif weak_success_count > 0 and failure_count == 0 and return_code == 0:
            return True
        elif weak_success_count > failure_count and return_code == 0:
            return True
        elif return_code == 0 and len(output.strip()) > 10 and failure_count == 0:
            # Assume success if no clear failure indicators and some output
            return True
        else:
            return False
    
    def _extract_artifacts_enhanced(self, output: str) -> List[str]:
        """Extract important artifacts from output"""
        artifacts = []
        
        patterns = [
            # Credentials
            r'(?:password|passwd|pwd|pass)[:=]\s*([^\s\n]{4,})',
            r'(?:username|user|login)[:=]\s*([^\s\n]{3,})',
            r'(?:token|key|secret|hash)[:=]\s*([^\s\n]{8,})',
            
            # Network information
            r'(?:shell|connection|session)\s+(?:on|at|to)\s+([\d\.]+)',
            r'(?:port|listening on)\s+(\d{1,5})',
            
            # File system
            r'(?:found|created|wrote|saved)\s+(?:file|directory)[:]\s*([^\s\n]+)',
            
            # Success confirmations
            r'(vulnerability\s+confirmed)',
            r'(exploit\s+successful)',
            r'(access\s+granted)',
            r'(privilege\s+escalation\s+successful)',
        ]
        
        for pattern in patterns:
            import re
            matches = re.findall(pattern, output, re.IGNORECASE)
            for match in matches:
                if isinstance(match, tuple):
                    artifacts.extend([str(m).strip() for m in match if str(m).strip()])
                else:
                    artifacts.append(str(match).strip())
        
        # Remove duplicates and limit
        unique_artifacts = list(set(artifacts))[:10]
        return unique_artifacts
    
    def _identify_success_indicators(self, output: str) -> List[str]:
        """Identify specific success indicators from output"""
        indicators = []
        output_lower = output.lower()
        
        success_patterns = {
            'Shell Access': ['shell', 'sh-', 'bash-', '$ ', '# '],
            'Network Connection': ['connected to', 'connection established'],
            'Authentication': ['logged in', 'authenticated', 'login successful'],
            'Privilege Escalation': ['root', 'admin', 'elevated', 'privilege'],
            'Code Execution': ['executed', 'payload', 'command executed'],
            'Vulnerability Confirmed': ['vulnerable', 'exploitable', 'confirmed']
        }
        
        for indicator_type, patterns in success_patterns.items():
            if any(pattern in output_lower for pattern in patterns):
                indicators.append(indicator_type)
        
        return indicators
    
    def _save_exploit_result(self, target_ip: str, cve_id: str, result: ExploitResult, poc_index: int):
        """Save individual exploit result"""
        try:
            cve_clean = cve_id.replace('CVE-', '').replace('cve-', '')
            filename = f"{target_ip}_exploit_{cve_clean}_{poc_index:03d}.json"
            filepath = config.DATA_DIR / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(result.model_dump(), f, indent=2, default=str)
            
            logger.debug(f"Exploit result saved: {filename}")
            
        except Exception as e:
            logger.error(f"Error saving exploit result: {e}")
