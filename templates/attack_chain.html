<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BreachPilot - Multi-Agent Attack Chain</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        .glass {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .gradient-text {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .node {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .node:hover {
            transform: scale(1.1);
        }
        
        .node-active {
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        .node-completed {
            filter: brightness(1.2);
        }
        
        .node-failed {
            filter: hue-rotate(0deg) brightness(0.8);
        }
        
        .link {
            transition: all 0.3s ease;
        }
        
        .link-active {
            stroke-width: 3px;
            animation: flow 2s linear infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { 
                filter: drop-shadow(0 0 5px rgba(59, 130, 246, 0.8));
            }
            50% { 
                filter: drop-shadow(0 0 15px rgba(59, 130, 246, 1));
            }
        }
        
        @keyframes flow {
            0% { stroke-dashoffset: 20; }
            100% { stroke-dashoffset: 0; }
        }
        
        .agent-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .agent-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .status-indicator {
            animation: pulse 2s infinite;
        }

        .cyber-grid {
            background-image: 
                linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen cyber-grid">
    <!-- Navigation -->
    <nav class="glass border-b border-gray-700 p-4 sticky top-0 z-50">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <h1 class="text-2xl font-bold gradient-text">BreachPilot</h1>
                <div class="text-xs text-purple-400 bg-purple-500/10 px-2 py-1 rounded">Multi-Agent Chain</div>
            </div>
            <div class="flex space-x-4">
                <a href="/" class="px-4 py-2 bg-gray-600/20 border border-gray-500/30 rounded-lg hover:bg-gray-600/30 transition">
                    üè† Home
                </a>
                <button id="stop-chain-btn" onclick="stopChain()" class="px-4 py-2 bg-red-600/20 border border-red-500/30 rounded-lg hover:bg-red-600/30 transition hidden">
                    ‚èπÔ∏è Stop Chain
                </button>
            </div>
        </div>
    </nav>

    <div class="container mx-auto p-6">
        <!-- Attack Chain Setup -->
        <div id="setup-section" class="glass rounded-lg p-6 mb-6">
            <h2 class="text-2xl font-semibold mb-4 gradient-text">Launch Multi-Agent Attack Chain</h2>
            
            <form id="chain-form" class="space-y-4">
                <div class="grid md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium mb-2">Target</label>
                        <input type="text" id="target" required
                               class="w-full p-3 bg-slate-800/50 border border-blue-500/30 rounded-lg focus:border-blue-400 focus:outline-none"
                               placeholder="e.g., 10.10.10.40, 10.10.10.75, 10.10.10.14">
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2">Objective</label>
                        <select id="objective" class="w-full p-3 bg-slate-800/50 border border-blue-500/30 rounded-lg">
                            <option value="full_compromise">Full System Compromise</option>
                            <option value="data_exfiltration">Data Exfiltration</option>
                            <option value="privilege_escalation">Privilege Escalation</option>
                            <option value="persistence">Maintain Persistence</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="authorize" class="text-blue-500">
                    <label for="authorize" class="text-sm text-gray-400">I authorize multi-agent testing on this target</label>
                </div>
                
                <button type="submit" class="w-full py-3 bg-gradient-to-r from-purple-600 to-pink-600 rounded-lg font-semibold hover:from-purple-700 hover:to-pink-700 transition transform hover:scale-105">
                    ‚ö° Launch Attack Chain
                </button>
            </form>
        </div>

        <!-- Chain Status -->
        <div id="status-section" class="hidden">
            <!-- Agent Status Cards -->
            <div class="grid md:grid-cols-3 lg:grid-cols-6 gap-4 mb-6">
                <div class="agent-card glass rounded-lg p-4 text-center">
                    <div class="text-2xl mb-2">üîç</div>
                    <div class="text-sm font-medium">Recon Specialist</div>
                    <div id="agent-recon-status" class="status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2"></div>
                </div>
                <div class="agent-card glass rounded-lg p-4 text-center">
                    <div class="text-2xl mb-2">üõ°Ô∏è</div>
                    <div class="text-sm font-medium">Vuln Analyst</div>
                    <div id="agent-vuln-status" class="status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2"></div>
                </div>
                <div class="agent-card glass rounded-lg p-4 text-center">
                    <div class="text-2xl mb-2">üí•</div>
                    <div class="text-sm font-medium">Exploit Engineer</div>
                    <div id="agent-exploit-status" class="status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2"></div>
                </div>
                <div class="agent-card glass rounded-lg p-4 text-center">
                    <div class="text-2xl mb-2">üîì</div>
                    <div class="text-sm font-medium">Post-Exploit</div>
                    <div id="agent-post-status" class="status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2"></div>
                </div>
                <div class="agent-card glass rounded-lg p-4 text-center">
                    <div class="text-2xl mb-2">üîó</div>
                    <div class="text-sm font-medium">Persistence</div>
                    <div id="agent-persist-status" class="status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2"></div>
                </div>
                <div class="agent-card glass rounded-lg p-4 text-center">
                    <div class="text-2xl mb-2">üéÆ</div>
                    <div class="text-sm font-medium">C2 Controller</div>
                    <div id="agent-c2-status" class="status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2"></div>
                </div>
            </div>

            <!-- Visualization Panel -->
            <div class="glass rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-4">Attack Flow Visualization</h3>
                <div id="visualization" class="bg-slate-800/50 rounded-lg border border-blue-500/20" style="height: 500px;"></div>
            </div>

            <!-- Live Logs -->
            <div class="glass rounded-lg p-6 mb-6">
                <h3 class="text-xl font-semibold mb-4">Live Agent Logs</h3>
                <div id="live-logs" class="bg-black rounded p-4 h-64 overflow-y-auto font-mono text-sm">
                    <div class="text-green-400">Waiting for chain execution...</div>
                </div>
            </div>

            <!-- Progress Summary -->
            <div id="progress-summary" class="grid md:grid-cols-4 gap-4">
                <div class="glass rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" id="total-tasks">0</div>
                    <div class="text-sm text-gray-400">Total Tasks</div>
                </div>
                <div class="glass rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-green-400" id="completed-tasks">0</div>
                    <div class="text-sm text-gray-400">Completed</div>
                </div>
                <div class="glass rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" id="active-agents">0</div>
                    <div class="text-sm text-gray-400">Active Agents</div>
                </div>
                <div class="glass rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-cyan-400" id="tools-executed">0</div>
                    <div class="text-sm text-gray-400">Tools Executed</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentChainId = null;
        let updateInterval = null;
        let svg = null;
        let simulation = null;

        // Initialize beautiful force-directed graph visualization
        function initVisualization() {
            const container = d3.select("#visualization");
            container.selectAll("*").remove();

            const width = container.node().getBoundingClientRect().width;
            const height = 500;

            svg = container.append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("background", "linear-gradient(135deg, #0f172a 0%, #1e293b 100%)");

            // Add sophisticated gradient definitions
            const defs = svg.append("defs");
            
            // Node gradients for different states
            const activeGradient = defs.append("radialGradient")
                .attr("id", "activeGradient")
                .attr("cx", "30%")
                .attr("cy", "30%");
            activeGradient.append("stop").attr("offset", "0%").attr("stop-color", "#60a5fa");
            activeGradient.append("stop").attr("offset", "100%").attr("stop-color", "#1e40af");

            const completedGradient = defs.append("radialGradient")
                .attr("id", "completedGradient")
                .attr("cx", "30%")
                .attr("cy", "30%");
            completedGradient.append("stop").attr("offset", "0%").attr("stop-color", "#34d399");
            completedGradient.append("stop").attr("offset", "100%").attr("stop-color", "#047857");

            const pendingGradient = defs.append("radialGradient")
                .attr("id", "pendingGradient")
                .attr("cx", "30%")
                .attr("cy", "30%");
            pendingGradient.append("stop").attr("offset", "0%").attr("stop-color", "#94a3b8");
            pendingGradient.append("stop").attr("offset", "100%").attr("stop-color", "#475569");

            // Enhanced arrow marker
            defs.append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "-0 -5 10 10")
                .attr("refX", 25)
                .attr("refY", 0)
                .attr("orient", "auto")
                .attr("markerWidth", 10)
                .attr("markerHeight", 10)
                .append("path")
                .attr("d", "M 0,-5 L 10,0 L 0,5")
                .attr("fill", "#64748b")
                .attr("opacity", 0.8);

            // Create force simulation with enhanced physics
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(50))
                .force("x", d3.forceX(width / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1));
        }

        function updateVisualization(data) {
            if (!svg || !data.visualization) return;

            const nodes = data.visualization.nodes || [];
            const links = data.visualization.edges?.map(e => ({from: e.from, to: e.to})) || [];

            // Create link data for D3
            const linkData = links.map(l => ({
                source: l.from,
                target: l.to
            }));

            // Update links with beautiful styling
            const link = svg.selectAll(".link")
                .data(linkData, d => `${d.source}-${d.target}`);

            link.exit().remove();

            const linkEnter = link.enter().append("line")
                .attr("class", "link")
                .attr("stroke", "#475569")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "8,4")
                .attr("marker-end", "url(#arrowhead)")
                .attr("opacity", 0);

            linkEnter.transition()
                .duration(800)
                .attr("opacity", 0.7);

            const linkUpdate = linkEnter.merge(link);

            // Update nodes with enhanced visuals
            const node = svg.selectAll(".node")
                .data(nodes, d => d.id);

            node.exit()
                .transition()
                .duration(500)
                .attr("transform", "scale(0)")
                .remove();

            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .style("cursor", "pointer")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Outer ring for status indication
            nodeEnter.append("circle")
                .attr("class", "node-ring")
                .attr("r", 35)
                .attr("fill", "none")
                .attr("stroke", "#1e293b")
                .attr("stroke-width", 3)
                .attr("opacity", 0)
                .transition()
                .duration(800)
                .attr("opacity", 0.8);

            // Main node circle with gradients
            nodeEnter.append("circle")
                .attr("class", "node-circle")
                .attr("r", 0)
                .attr("fill", d => getNodeGradient(d.status))
                .attr("stroke", "#1e293b")
                .attr("stroke-width", 2)
                .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))")
                .transition()
                .duration(800)
                .attr("r", 28);

            // Agent icons with better positioning
            nodeEnter.append("text")
                .attr("class", "node-icon")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .attr("font-size", "18px")
                .text(d => getAgentIcon(d.agent))
                .attr("opacity", 0)
                .transition()
                .duration(800)
                .delay(300)
                .attr("opacity", 1);

            // Status indicators
            nodeEnter.append("circle")
                .attr("class", "status-dot")
                .attr("cx", 20)
                .attr("cy", -20)
                .attr("r", 0)
                .attr("fill", d => getStatusColor(d.status))
                .transition()
                .duration(500)
                .delay(600)
                .attr("r", 6);

            // Enhanced labels with background
            const labelGroup = nodeEnter.append("g")
                .attr("class", "label-group")
                .attr("transform", "translate(0, 45)");

            labelGroup.append("rect")
                .attr("class", "label-bg")
                .attr("x", -30)
                .attr("y", -8)
                .attr("width", 60)
                .attr("height", 16)
                .attr("rx", 8)
                .attr("fill", "rgba(15, 23, 42, 0.9)")
                .attr("stroke", "#334155")
                .attr("stroke-width", 1)
                .attr("opacity", 0)
                .transition()
                .duration(500)
                .delay(800)
                .attr("opacity", 1);

            labelGroup.append("text")
                .attr("class", "node-label")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .attr("font-size", "9px")
                .attr("fill", "#94a3b8")
                .text(d => d.name.substring(0, 10) + (d.name.length > 10 ? "..." : ""))
                .attr("opacity", 0)
                .transition()
                .duration(500)
                .delay(800)
                .attr("opacity", 1);

            const nodeUpdate = nodeEnter.merge(node);

            // Update existing nodes
            nodeUpdate.select(".node-circle")
                .transition()
                .duration(500)
                .attr("fill", d => getNodeGradient(d.status))
                .style("filter", d => {
                    if (d.status === "running") return "drop-shadow(0 0 15px rgba(59, 130, 246, 0.8))";
                    if (d.status === "completed") return "drop-shadow(0 0 10px rgba(16, 185, 129, 0.6))";
                    return "drop-shadow(0 4px 8px rgba(0,0,0,0.3))";
                });

            nodeUpdate.select(".node-ring")
                .transition()
                .duration(500)
                .attr("stroke", d => getStatusColor(d.status))
                .attr("stroke-dasharray", d => d.status === "running" ? "5,5" : "none")
                .style("animation", d => d.status === "running" ? "spin 2s linear infinite" : "none");

            nodeUpdate.select(".status-dot")
                .transition()
                .duration(300)
                .attr("fill", d => getStatusColor(d.status));

            // Update simulation with better forces
            simulation.nodes(nodes);
            simulation.force("link").links(linkData);
            simulation.alpha(0.5).restart();

            // Enhanced tick function for smoother animation
            simulation.on("tick", () => {
                linkUpdate
                    .attr("x1", d => Math.max(35, Math.min(svg.attr("width") - 35, d.source.x)))
                    .attr("y1", d => Math.max(35, Math.min(svg.attr("height") - 35, d.source.y)))
                    .attr("x2", d => Math.max(35, Math.min(svg.attr("width") - 35, d.target.x)))
                    .attr("y2", d => Math.max(35, Math.min(svg.attr("height") - 35, d.target.y)));

                nodeUpdate
                    .attr("transform", d => {
                        d.x = Math.max(35, Math.min(svg.attr("width") - 35, d.x));
                        d.y = Math.max(35, Math.min(svg.attr("height") - 35, d.y));
                        return `translate(${d.x},${d.y})`;
                    });
            });
        }

        function getNodeGradient(status) {
            switch (status) {
                case "running": return "url(#activeGradient)";
                case "completed": return "url(#completedGradient)";
                case "failed": return "#ef4444";
                default: return "url(#pendingGradient)";
            }
        }

        function getStatusColor(status) {
            switch (status) {
                case "pending": return "#64748b";
                case "running": return "#3b82f6";
                case "completed": return "#10b981";
                case "failed": return "#ef4444";
                default: return "#64748b";
            }
        }

        function getAgentIcon(agent) {
            const icons = {
                "recon_specialist": "üîç",
                "vulnerability_analyst": "üõ°Ô∏è",
                "exploit_engineer": "üí•",
                "post_exploit_specialist": "üîì",
                "persistence_expert": "üîó",
                "command_controller": "üéÆ"
            };
            return icons[agent] || "ü§ñ";
        }

        // Enhanced drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Form submission
        document.getElementById('chain-form').addEventListener('submit', async function(e) {
            e.preventDefault();

            const target = document.getElementById('target').value;
            const objective = document.getElementById('objective').value;
            const authorize = document.getElementById('authorize').checked;

            if (!authorize) {
                alert('Please authorize the attack chain execution');
                return;
            }

            try {
                const response = await fetch('/api/attack-chain/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target, objective })
                });

                const data = await response.json();

                if (data.chain_id) {
                    currentChainId = data.chain_id;
                    document.getElementById('setup-section').classList.add('hidden');
                    document.getElementById('status-section').classList.remove('hidden');
                    document.getElementById('stop-chain-btn').classList.remove('hidden');

                    initVisualization();
                    startChainExecution();
                    updateInterval = setInterval(updateChainStatus, 2000);
                } else {
                    alert('Failed to create attack chain: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to create attack chain');
            }
        });

        async function startChainExecution() {
            try {
                await fetch(`/api/attack-chain/${currentChainId}/execute`, {
                    method: 'POST'
                });
            } catch (error) {
                console.error('Error starting chain execution:', error);
            }
        }

        async function updateChainStatus() {
            if (!currentChainId) return;

            try {
                const response = await fetch(`/api/attack-chain/${currentChainId}/status`);
                const data = await response.json();

                if (data.error) {
                    console.error('Chain status error:', data.error);
                    return;
                }

                // Update visualization
                updateVisualization(data);

                // Update agent status indicators
                updateAgentStatuses(data.agent_states || []);

                // Update progress summary
                updateProgressSummary(data);

                // Update logs
                updateLiveLogs(data.logs || []);

                // Check if completed
                if (data.status === 'completed' || data.status === 'failed') {
                    clearInterval(updateInterval);
                    document.getElementById('stop-chain-btn').classList.add('hidden');
                }

            } catch (error) {
                console.error('Error updating chain status:', error);
            }
        }

        function updateAgentStatuses(agentStates) {
            const statusElements = {
                "recon_specialist": "agent-recon-status",
                "vulnerability_analyst": "agent-vuln-status", 
                "exploit_engineer": "agent-exploit-status",
                "post_exploit_specialist": "agent-post-status",
                "persistence_expert": "agent-persist-status",
                "command_controller": "agent-c2-status"
            };

            // Reset all to idle
            Object.values(statusElements).forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.className = "status-indicator w-3 h-3 bg-gray-500 rounded-full mx-auto mt-2";
                }
            });

            // Update based on agent states
            agentStates.forEach(agent => {
                const elementId = statusElements[agent.role];
                const element = document.getElementById(elementId);
                
                if (element) {
                    let colorClass = "bg-gray-500";
                    if (agent.status === "busy") colorClass = "bg-blue-500";
                    else if (agent.completed_tasks_count > 0) colorClass = "bg-green-500";
                    
                    element.className = `status-indicator w-3 h-3 ${colorClass} rounded-full mx-auto mt-2`;
                }
            });
        }

        function updateProgressSummary(data) {
            document.getElementById('total-tasks').textContent = data.performance_metrics?.total_tools || 0;
            document.getElementById('completed-tasks').textContent = 
                data.agent_states?.reduce((sum, agent) => sum + agent.completed_tasks_count, 0) || 0;
            document.getElementById('active-agents').textContent = data.performance_metrics?.active_agents || 0;
            document.getElementById('tools-executed').textContent = 
                data.agent_states?.reduce((sum, agent) => sum + agent.tools_available, 0) || 0;
        }

        function updateLiveLogs(logs) {
            const logsContainer = document.getElementById('live-logs');
            
            // Only show recent logs
            const recentLogs = logs.slice(-20);
            
            logsContainer.innerHTML = recentLogs.map(log => {
                const time = new Date(log.timestamp).toLocaleTimeString();
                const levelColor = {
                    'info': 'text-blue-400',
                    'success': 'text-green-400',
                    'warning': 'text-yellow-400',
                    'error': 'text-red-400'
                }[log.level] || 'text-gray-400';
                
                return `<div class="${levelColor}">[${time}] ${log.message}</div>`;
            }).join('');
            
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }

        async function stopChain() {
            if (!currentChainId) return;
            
            if (!confirm('Are you sure you want to stop the attack chain?')) return;
            
            try {
                await fetch(`/api/attack-chain/${currentChainId}/stop`, {
                    method: 'POST'
                });
                
                clearInterval(updateInterval);
                document.getElementById('stop-chain-btn').classList.add('hidden');
                
            } catch (error) {
                console.error('Error stopping chain:', error);
                alert('Failed to stop attack chain');
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Auto-resize visualization on window resize
            window.addEventListener('resize', function() {
                if (svg) {
                    setTimeout(initVisualization, 100);
                }
            });
        });
    </script>

    <style>
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .node-ring {
            animation: none;
        }
        
        .node-ring[data-status="running"] {
            animation: spin 3s linear infinite;
        }
    </style>
</body>
</html>